--- old.mixinIntersectionIsValidbaseType.types
+++ new.mixinIntersectionIsValidbaseType.types
@@= skipped -14, +14 lines =@@
  * Plain mixin where the superclass must be Initable
  */
 export const Serializable = <K extends Constructor<Initable> & Initable>(
->Serializable : <K extends Constructor<Initable> & Initable>(SuperClass: K) => { new (...args: any[]): SerializableLocal; prototype: Serializable<any>.SerializableLocal; init(...args: any[]): void; } & K
-><K extends Constructor<Initable> & Initable>(    SuperClass: K) => {    const LocalMixin = (InnerSuperClass: K) => {        return class SerializableLocal extends InnerSuperClass {        }    };    let ResultClass = LocalMixin(SuperClass);    return ResultClass;} : <K extends Constructor<Initable> & Initable>(SuperClass: K) => { new (...args: any[]): SerializableLocal; prototype: Serializable<any>.SerializableLocal; init(...args: any[]): void; } & K
+>Serializable : <K extends Constructor<Initable> & Initable>(SuperClass: K) => { new (...args: any[]): SerializableLocal<K>; init: (...args: any[]) => void; prototype: SerializableLocal<any>; } & K
+><K extends Constructor<Initable> & Initable>(    SuperClass: K) => {    const LocalMixin = (InnerSuperClass: K) => {        return class SerializableLocal extends InnerSuperClass {        }    };    let ResultClass = LocalMixin(SuperClass);    return ResultClass;} : <K extends Constructor<Initable> & Initable>(SuperClass: K) => { new (...args: any[]): SerializableLocal<K>; init: (...args: any[]) => void; prototype: SerializableLocal<any>; } & K
 
     SuperClass: K
 >SuperClass : K
 
 ) => {
     const LocalMixin = (InnerSuperClass: K) => {
->LocalMixin : (InnerSuperClass: K) => { new (...args: any[]): SerializableLocal; prototype: Serializable<any>.SerializableLocal; init(...args: any[]): void; } & K
->(InnerSuperClass: K) => {        return class SerializableLocal extends InnerSuperClass {        }    } : (InnerSuperClass: K) => { new (...args: any[]): SerializableLocal; prototype: Serializable<any>.SerializableLocal; init(...args: any[]): void; } & K
+>LocalMixin : (InnerSuperClass: K) => { new (...args: any[]): SerializableLocal<K>; init: (...args: any[]) => void; prototype: SerializableLocal<any>; } & K
+>(InnerSuperClass: K) => {        return class SerializableLocal extends InnerSuperClass {        }    } : (InnerSuperClass: K) => { new (...args: any[]): SerializableLocal<K>; init: (...args: any[]) => void; prototype: SerializableLocal<any>; } & K
 >InnerSuperClass : K
 
         return class SerializableLocal extends InnerSuperClass {
->class SerializableLocal extends InnerSuperClass {        } : { new (...args: any[]): SerializableLocal; prototype: Serializable<any>.SerializableLocal; init(...args: any[]): void; } & K
->SerializableLocal : { new (...args: any[]): SerializableLocal; prototype: Serializable<any>.SerializableLocal; init(...args: any[]): void; } & K
+>class SerializableLocal extends InnerSuperClass {        } : { new (...args: any[]): SerializableLocal<K>; init: (...args: any[]) => void; prototype: SerializableLocal<any>; } & K
+>SerializableLocal : { new (...args: any[]): SerializableLocal<K>; init: (...args: any[]) => void; prototype: SerializableLocal<any>; } & K
 >InnerSuperClass : Initable
         }
     };
     let ResultClass = LocalMixin(SuperClass);
->ResultClass : { new (...args: any[]): SerializableLocal; prototype: Serializable<any>.SerializableLocal; init(...args: any[]): void; } & K
->LocalMixin(SuperClass) : { new (...args: any[]): SerializableLocal; prototype: Serializable<any>.SerializableLocal; init(...args: any[]): void; } & K
->LocalMixin : (InnerSuperClass: K) => { new (...args: any[]): SerializableLocal; prototype: Serializable<any>.SerializableLocal; init(...args: any[]): void; } & K
+>ResultClass : { new (...args: any[]): SerializableLocal<K>; init: (...args: any[]) => void; prototype: SerializableLocal<any>; } & K
+>LocalMixin(SuperClass) : { new (...args: any[]): SerializableLocal<K>; init: (...args: any[]) => void; prototype: SerializableLocal<any>; } & K
+>LocalMixin : (InnerSuperClass: K) => { new (...args: any[]): SerializableLocal<K>; init: (...args: any[]) => void; prototype: SerializableLocal<any>; } & K
 >SuperClass : K
 
     return ResultClass;
->ResultClass : { new (...args: any[]): SerializableLocal; prototype: Serializable<any>.SerializableLocal; init(...args: any[]): void; } & K
+>ResultClass : { new (...args: any[]): SerializableLocal<K>; init: (...args: any[]) => void; prototype: SerializableLocal<any>; } & K
 
 };
 
@@= skipped -35, +35 lines =@@
 >SuperClass : K
 
     let SomeHowOkay = class A extends SuperClass {
->SomeHowOkay : { new (...args: any[]): A; prototype: AMixin<any>.A; init(...args: any[]): void; } & K
->class A extends SuperClass {    } : { new (...args: any[]): A; prototype: AMixin<any>.A; init(...args: any[]): void; } & K
->A : { new (...args: any[]): A; prototype: AMixin<any>.A; init(...args: any[]): void; } & K
+>SomeHowOkay : { new (...args: any[]): A<K>; init: (...args: any[]) => void; prototype: A<any>; } & K
+>class A extends SuperClass {    } : { new (...args: any[]): A<K>; init: (...args: any[]) => void; prototype: A<any>; } & K
+>A : { new (...args: any[]): A<K>; init: (...args: any[]) => void; prototype: A<any>; } & K
 >SuperClass : Initable
 
     };
 
     let SomeHowNotOkay = class A extends Serializable(SuperClass) {
->SomeHowNotOkay : { new (...args: any[]): A; prototype: AMixin<any>.A; init(...args: any[]): void; } & K
->class A extends Serializable(SuperClass) {    } : { new (...args: any[]): A; prototype: AMixin<any>.A; init(...args: any[]): void; } & K
->A : { new (...args: any[]): A; prototype: AMixin<any>.A; init(...args: any[]): void; } & K
->Serializable(SuperClass) : Serializable<K>.SerializableLocal & Initable
->Serializable : <K_1 extends Constructor<Initable> & Initable>(SuperClass: K_1) => { new (...args: any[]): SerializableLocal; prototype: Serializable<any>.SerializableLocal; init(...args: any[]): void; } & K_1
+>SomeHowNotOkay : { new (...args: any[]): A<K>; init: (...args: any[]) => void; prototype: A<any>; } & K
+>class A extends Serializable(SuperClass) {    } : { new (...args: any[]): A<K>; init: (...args: any[]) => void; prototype: A<any>; } & K
+>A : { new (...args: any[]): A<K>; init: (...args: any[]) => void; prototype: A<any>; } & K
+>Serializable(SuperClass) : SerializableLocal<K> & Initable
+>Serializable : <K extends Constructor<Initable> & Initable>(SuperClass: K) => { new (...args: any[]): SerializableLocal<K>; init: (...args: any[]) => void; prototype: SerializableLocal<any>; } & K
 >SuperClass : K
 
     };

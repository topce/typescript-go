--- old.inferTypePredicates.js
+++ new.inferTypePredicates.js
@@= skipped -281, +281 lines =@@
 
 
 //// [inferTypePredicates.js]
-// https://github.com/microsoft/TypeScript/issues/16069
-var __extends = (this && this.__extends) || (function () {
-    var extendStatics = function (d, b) {
-        extendStatics = Object.setPrototypeOf ||
-            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
-            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
-        return extendStatics(d, b);
-    };
-    return function (d, b) {
-        if (typeof b !== "function" && b !== null)
-            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
-        extendStatics(d, b);
-        function __() { this.constructor = d; }
-        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-    };
-})();
-var numsOrNull = [1, 2, 3, 4, null];
-var filteredNumsTruthy = numsOrNull.filter(function (x) { return !!x; }); // should error
-var filteredNumsNonNullish = numsOrNull.filter(function (x) { return x !== null; }); // should ok
-var evenSquaresInline = // should error
- [1, 2, 3, 4]
-    .map(function (x) { return x % 2 === 0 ? x * x : null; })
-    .filter(function (x) { return !!x; }); // tests truthiness, not non-nullishness
-var isTruthy = function (x) { return !!x; };
-var evenSquares = // should error
- [1, 2, 3, 4]
-    .map(function (x) { return x % 2 === 0 ? x * x : null; })
+const numsOrNull = [1, 2, 3, 4, null];
+const filteredNumsTruthy = numsOrNull.filter(x => !!x);
+const filteredNumsNonNullish = numsOrNull.filter(x => x !== null);
+const evenSquaresInline = [1, 2, 3, 4]
+    .map(x => x % 2 === 0 ? x * x : null)
+    .filter(x => !!x);
+const isTruthy = (x) => !!x;
+const evenSquares = [1, 2, 3, 4]
+    .map(x => x % 2 === 0 ? x * x : null)
     .filter(isTruthy);
-var evenSquaresNonNull = // should ok
- [1, 2, 3, 4]
-    .map(function (x) { return x % 2 === 0 ? x * x : null; })
-    .filter(function (x) { return x !== null; });
+const evenSquaresNonNull = [1, 2, 3, 4]
+    .map(x => x % 2 === 0 ? x * x : null)
+    .filter(x => x !== null);
 function isNonNull(x) {
     return x !== null;
 }
-// factoring out a boolean works thanks to aliased discriminants
 function isNonNullVar(x) {
-    var ok = x !== null;
+    const ok = x !== null;
     return ok;
 }
 function isNonNullGeneric(x) {
     return x !== null;
 }
-// Type guards can flow between functions
-var myGuard = function (o) { return !!o; };
-var mySecondGuard = function (o) { return myGuard(o); };
-var myArray = [];
-var result = myArray
-    .map(function (arr) { return arr.list; })
-    .filter(function (arr) { return arr && arr.length; })
-    .map(function (arr) { return arr // should error
-    .filter(function (obj) { return obj && obj.data; })
-    .map(function (obj) { return JSON.parse(obj.data); }); } // should error
-);
-var result2 = myArray
-    .map(function (arr) { return arr.list; })
-    .filter(function (arr) { return !!arr; })
-    .filter(function (arr) { return arr.length; })
-    .map(function (arr) { return arr // should ok
-    .filter(function (obj) { return obj; })
-    // inferring a guard here would require https://github.com/microsoft/TypeScript/issues/42384
-    .filter(function (obj) { return !!obj.data; })
-    .map(function (obj) { return JSON.parse(obj.data); }); });
-var list = [];
-var resultBars = list.filter(function (value) { return 'bar' in value; }); // should ok
+const myGuard = (o) => !!o;
+const mySecondGuard = (o) => myGuard(o);
+const myArray = [];
+const result = myArray
+    .map((arr) => arr.list)
+    .filter((arr) => arr && arr.length)
+    .map((arr) => arr
+    .filter((obj) => obj && obj.data)
+    .map(obj => JSON.parse(obj.data)));
+const result2 = myArray
+    .map((arr) => arr.list)
+    .filter((arr) => !!arr)
+    .filter(arr => arr.length)
+    .map((arr) => arr
+    .filter((obj) => obj)
+    .filter(obj => !!obj.data)
+    .map(obj => JSON.parse(obj.data)));
+const list = [];
+const resultBars = list.filter((value) => 'bar' in value);
 function isBarNonNull(x) {
     return ('bar' in x);
 }
-var fooOrBar = list[0];
+const fooOrBar = list[0];
 if (isBarNonNull(fooOrBar)) {
-    var t = fooOrBar; // should ok
+    const t = fooOrBar;
 }
-// https://github.com/microsoft/TypeScript/issues/38390#issuecomment-626019466
-// Ryan's example (currently legal):
-var a = [1, "foo", 2, "bar"].filter(function (x) { return typeof x === "string"; });
+const a = [1, "foo", 2, "bar"].filter(x => typeof x === "string");
 a.push(10);
-// Defer to explicit type guards, even when they're incorrect.
 function backwardsGuard(x) {
     return typeof x === 'string';
 }
-// Partition tests. The "false" case matters.
 function isString(x) {
     return typeof x === 'string';
 }
 if (isString(strOrNum)) {
-    var t = strOrNum; // should ok
+    let t = strOrNum;
 }
 else {
-    var t = strOrNum; // should ok
+    let t = strOrNum;
 }
 function flakyIsString(x) {
     return typeof x === 'string' && Math.random() > 0.5;
 }
 if (flakyIsString(strOrNum)) {
-    var t = strOrNum; // should error
+    let t = strOrNum;
 }
 else {
-    var t = strOrNum; // should error
+    let t = strOrNum;
 }
 function isDate(x) {
     return x instanceof Date;
@@= skipped -106, +79 lines =@@
     return x instanceof Date && Math.random() > 0.5;
 }
 if (isDate(maybeDate)) {
-    var t = maybeDate; // should ok
+    let t = maybeDate;
 }
 else {
-    var t = maybeDate; // should ok
+    let t = maybeDate;
 }
 if (flakyIsDate(maybeDate)) {
-    var t = maybeDate; // should error
+    let t = maybeDate;
 }
 else {
-    var t = maybeDate; // should ok
+    let t = maybeDate;
 }
-// This should not infer a type guard since the value on which we do the refinement
-// is not related to the original parameter.
 function irrelevantIsNumber(x) {
     x = Math.random() < 0.5 ? "string" : 123;
     return typeof x === 'string';
 }
 function irrelevantIsNumberDestructuring(x) {
-    x = [Math.random() < 0.5 ? "string" : 123][0];
+    [x] = [Math.random() < 0.5 ? "string" : 123];
     return typeof x === 'string';
 }
-// Cannot infer a type guard for either param because of the false case.
 function areBothNums(x, y) {
     return typeof x === 'number' && typeof y === 'number';
 }
-// Could potentially infer a type guard here but it would require more bookkeeping.
 function doubleReturn(x) {
     if (typeof x === 'string') {
         return true;
@@= skipped -35, +31 lines =@@
 function guardsOneButNotOthers(a, b, c) {
     return typeof b === 'string';
 }
-// Checks that there are no string escaping issues
 function dunderguard(__x) {
     return typeof __x === 'string';
 }
-// could infer a type guard here but it doesn't seem that helpful.
-var booleanIdentity = function (x) { return x; };
-// we infer "x is number | true" which is accurate but of debatable utility.
-var numOrBoolean = function (x) { return typeof x === 'number' || x; };
-var Inferrer = /** @class */ (function () {
-    function Inferrer() {
-    }
-    Inferrer.prototype.isNumber = function (x) {
+const booleanIdentity = (x) => x;
+const numOrBoolean = (x) => typeof x === 'number' || x;
+class Inferrer {
+    isNumber(x) {
         return typeof x === 'number';
-    };
-    return Inferrer;
-}());
-var inf = new Inferrer();
+    }
+}
+const inf = new Inferrer();
 if (inf.isNumber(numOrStr)) {
-    var t = numOrStr; // should ok
+    let t = numOrStr;
 }
 else {
-    var t = numOrStr; // should ok
+    let t = numOrStr;
 }
-// Type predicates are not inferred on "this"
-var C1 = /** @class */ (function () {
-    function C1() {
-    }
-    C1.prototype.isC2 = function () {
+class C1 {
+    isC2() {
         return this instanceof C2;
-    };
-    return C1;
-}());
-var C2 = /** @class */ (function (_super) {
-    __extends(C2, _super);
-    function C2() {
-        var _this = _super !== null && _super.apply(this, arguments) || this;
-        _this.z = 0;
-        return _this;
     }
-    return C2;
-}(C1));
+}
+class C2 extends C1 {
+    z = 0;
+}
 if (c.isC2()) {
-    var c2 = c; // should error
+    let c2 = c;
 }
-function doNotRefineDestructuredParam(_a) {
-    var x = _a.x, y = _a.y;
+function doNotRefineDestructuredParam({ x, y }) {
     return typeof x === 'number';
 }
-// The type predicate must remain valid when the function is called with subtypes.
 function isShortString(x) {
     return typeof x === "string" && x.length < 10;
 }
 if (isShortString(str)) {
-    str.charAt(0); // should ok
+    str.charAt(0);
 }
 else {
-    str.charAt(0); // should ok
+    str.charAt(0);
 }
 function isStringFromUnknown(x) {
     return typeof x === "string";
 }
 if (isStringFromUnknown(str)) {
-    str.charAt(0); // should OK
+    str.charAt(0);
 }
 else {
-    var t = str; // should OK
+    let t = str;
 }
-// infer a union type
 function isNumOrStr(x) {
     return (typeof x === "number" || typeof x === "string");
 }
 if (isNumOrStr(unk)) {
-    var t = unk; // should ok
+    let t = unk;
 }
-// A function can be a type predicate even if it throws.
 function assertAndPredicate(x) {
     if (x instanceof Date) {
         throw new Error();
@@= skipped -82, +62 lines =@@
     return typeof x === 'string';
 }
 if (assertAndPredicate(snd)) {
-    var t = snd; // should error
+    let t = snd;
 }
 function isNumberWithThis(x) {
     return typeof x === 'number';
@@= skipped -8, +8 lines =@@
 function narrowFromAny(x) {
     return typeof x === 'number';
 }
-var noInferenceFromRest = function () {
-    var f = [];
-    for (var _i = 0; _i < arguments.length; _i++) {
-        f[_i] = arguments[_i];
-    }
-    return f[0] === "a";
-};
-var noInferenceFromImpossibleRest = function () {
-    var f = [];
-    for (var _i = 0; _i < arguments.length; _i++) {
-        f[_i] = arguments[_i];
-    }
-    return typeof f === "undefined";
-};
-function inferWithRest(x) {
-    var f = [];
-    for (var _i = 1; _i < arguments.length; _i++) {
-        f[_i - 1] = arguments[_i];
-    }
+const noInferenceFromRest = (...f) => f[0] === "a";
+const noInferenceFromImpossibleRest = (...f) => typeof f === "undefined";
+function inferWithRest(x, ...f) {
     return typeof x === 'string';
 }
-var foobarPred = function (fb) { return fb.type === "foo"; };
+const foobarPred = (fb) => fb.type === "foo";
 if (foobarPred(foobar)) {
     foobar.foo;
 }
-
-
-//// [inferTypePredicates.d.ts]
-declare const numsOrNull: (number | null)[];
-declare const filteredNumsTruthy: number[];
-declare const filteredNumsNonNullish: number[];
-declare const evenSquaresInline: number[];
-declare const isTruthy: (x: number | null) => boolean;
-declare const evenSquares: number[];
-declare const evenSquaresNonNull: number[];
-declare function isNonNull(x: number | null): x is number;
-declare function isNonNullVar(x: number | null): x is number;
-declare function isNonNullGeneric<T>(x: T): x is T & ({} | undefined);
-declare const myGuard: (o: string | undefined) => o is string;
-declare const mySecondGuard: (o: string | undefined) => o is string;
-type MyObj = {
-    data?: string;
-};
-type MyArray = {
-    list?: MyObj[];
-}[];
-declare const myArray: MyArray;
-declare const result: any[][];
-declare const result2: any[][];
-type Foo = {
-    foo: string;
-};
-type Bar = Foo & {
-    bar: string;
-};
-declare const list: (Foo | Bar)[];
-declare const resultBars: Bar[];
-declare function isBarNonNull(x: Foo | Bar | null): x is Bar;
-declare const fooOrBar: Foo | Bar;
-declare const a: string[];
-declare function backwardsGuard(x: number | string): x is number;
-declare function isString(x: string | number): x is string;
-declare let strOrNum: string | number;
-declare function flakyIsString(x: string | number): boolean;
-declare function isDate(x: object): x is Date;
-declare function flakyIsDate(x: object): boolean;
-declare let maybeDate: object;
-declare function irrelevantIsNumber(x: string | number): boolean;
-declare function irrelevantIsNumberDestructuring(x: string | number): boolean;
-declare function areBothNums(x: string | number, y: string | number): boolean;
-declare function doubleReturn(x: string | number): boolean;
-declare function guardsOneButNotOthers(a: string | number, b: string | number, c: string | number): b is string;
-declare function dunderguard(__x: number | string): __x is string;
-declare const booleanIdentity: (x: boolean) => boolean;
-declare const numOrBoolean: (x: number | boolean) => x is number | true;
-interface NumberInferrer {
-    isNumber(x: number | string): x is number;
-}
-declare class Inferrer implements NumberInferrer {
-    isNumber(x: number | string): x is number;
-}
-declare let numOrStr: number | string;
-declare const inf: Inferrer;
-declare class C1 {
-    isC2(): boolean;
-}
-declare class C2 extends C1 {
-    z: number;
-}
-declare let c: C1;
-declare function doNotRefineDestructuredParam({ x, y }: {
-    x: number | null;
-    y: number;
-}): boolean;
-declare function isShortString(x: unknown): boolean;
-declare let str: string;
-declare function isStringFromUnknown(x: unknown): x is string;
-declare function isNumOrStr(x: unknown): x is string | number;
-declare let unk: unknown;
-declare function assertAndPredicate(x: string | number | Date): x is string;
-declare let snd: string | number | Date;
-declare function isNumberWithThis(this: Date, x: number | string): x is number;
-declare function narrowFromAny(x: any): x is number;
-declare const noInferenceFromRest: (f_0: "a" | "b") => boolean;
-declare const noInferenceFromImpossibleRest: () => boolean;
-declare function inferWithRest(x: string | null, ...f: ["a", "b"]): x is string;
-declare const foobar: {
-    type: "foo";
-    foo: number;
-} | {
-    type: "bar";
-    bar: string;
-};
-declare const foobarPred: (fb: typeof foobar) => fb is {
-    type: "foo";
-    foo: number;
-};

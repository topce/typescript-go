--- old.declarationsWithRecursiveInternalTypesProduceUniqueTypeParams.types
+++ new.declarationsWithRecursiveInternalTypesProduceUniqueTypeParams.types
@@= skipped -0, +0 lines =@@
 //// [tests/cases/compiler/declarationsWithRecursiveInternalTypesProduceUniqueTypeParams.ts] ////
 
-=== Performance Stats ===
-Instantiation count: 500 -> 2,500
-
 === declarationsWithRecursiveInternalTypesProduceUniqueTypeParams.ts ===
 // Note that both of the following have an `any` in their return type from where we bottom out the type printout
 // for having too many instances of the same symbol nesting.
@@= skipped -14, +11 lines =@@
 >Value : Value<K, U>
 
 export const updateIfChanged = <T>(t: T) => {
->updateIfChanged : <T>(t: T) => (<K extends keyof T>(key: K) => (<K_1 extends keyof Value<K, T>>(key: K_1) => (<K_2 extends keyof Value<K_1, Value<K, T>>>(key: K_2) => (<K_3 extends keyof Value<K_2, Value<K_1, Value<K, T>>>>(key: K_3) => (<K_4 extends keyof Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>(key: K_4) => (<K_5 extends keyof Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>(key: K_5) => (<K_6 extends keyof Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>(key: K_6) => (<K_7 extends keyof Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>(key: K_7) => (<K_8 extends keyof Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>(key: K_8) => (<K_9 extends keyof Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>(key: K_9) => (<K_10 extends keyof Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>(key: K_10) => any & { map: (updater: (u: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>) => Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>) => T; set: (newU: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>) => Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>) => T; set: (newU: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>) => Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>) => T; set: (newU: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>) => Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>) => T; set: (newU: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>) => Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>) => T; set: (newU: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>) => T; }) & { map: (updater: (u: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>) => Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>) => T; set: (newU: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>) => T; }) & { map: (updater: (u: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>) => Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>) => T; set: (newU: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>) => T; }) & { map: (updater: (u: Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>) => Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>) => T; set: (newU: Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>) => T; }) & { map: (updater: (u: Value<K_2, Value<K_1, Value<K, T>>>) => Value<K_2, Value<K_1, Value<K, T>>>) => T; set: (newU: Value<K_2, Value<K_1, Value<K, T>>>) => T; }) & { map: (updater: (u: Value<K_1, Value<K, T>>) => Value<K_1, Value<K, T>>) => T; set: (newU: Value<K_1, Value<K, T>>) => T; }) & { map: (updater: (u: Value<K, T>) => Value<K, T>) => T; set: (newU: Value<K, T>) => T; }) & { map: (updater: (u: T) => T) => T; set: (newU: T) => T; }
-><T>(t: T) => {    const reduce = <U>(u: U, update: (u: U) => T) => {        const set = (newU: U) => Object.is(u, newU) ? t : update(newU);        return Object.assign(            <K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }),            { map: (updater: (u: U) => U) => set(updater(u)), set });    };    return reduce<T>(t, (t: T) => t);} : <T>(t: T) => (<K extends keyof T>(key: K) => (<K_1 extends keyof Value<K, T>>(key: K_1) => (<K_2 extends keyof Value<K_1, Value<K, T>>>(key: K_2) => (<K_3 extends keyof Value<K_2, Value<K_1, Value<K, T>>>>(key: K_3) => (<K_4 extends keyof Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>(key: K_4) => (<K_5 extends keyof Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>(key: K_5) => (<K_6 extends keyof Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>(key: K_6) => (<K_7 extends keyof Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>(key: K_7) => (<K_8 extends keyof Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>(key: K_8) => (<K_9 extends keyof Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>(key: K_9) => (<K_10 extends keyof Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>(key: K_10) => any & { map: (updater: (u: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>) => Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>) => T; set: (newU: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>) => Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>) => T; set: (newU: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>) => Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>) => T; set: (newU: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>) => Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>) => T; set: (newU: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>) => Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>) => T; set: (newU: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>) => T; }) & { map: (updater: (u: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>) => Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>) => T; set: (newU: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>) => T; }) & { map: (updater: (u: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>) => Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>) => T; set: (newU: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>) => T; }) & { map: (updater: (u: Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>) => Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>) => T; set: (newU: Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>) => T; }) & { map: (updater: (u: Value<K_2, Value<K_1, Value<K, T>>>) => Value<K_2, Value<K_1, Value<K, T>>>) => T; set: (newU: Value<K_2, Value<K_1, Value<K, T>>>) => T; }) & { map: (updater: (u: Value<K_1, Value<K, T>>) => Value<K_1, Value<K, T>>) => T; set: (newU: Value<K_1, Value<K, T>>) => T; }) & { map: (updater: (u: Value<K, T>) => Value<K, T>) => T; set: (newU: Value<K, T>) => T; }) & { map: (updater: (u: T) => T) => T; set: (newU: T) => T; }
+>updateIfChanged : <T>(t: T) => <K extends keyof T>(key: K) => <K extends keyof Value<K, T>>(key: K) => <K extends keyof Value<K, Value<K, T>>>(key: K) => <K extends ???>(key: K) => ??? & ??? & { map: ???; set: ???; } & { map: (updater: (u: Value<K, Value<K, T>>) => Value<K, Value<K, T>>) => T; set: (newU: Value<K, Value<K, T>>) => T; } & { map: (updater: (u: Value<K, T>) => Value<K, T>) => T; set: (newU: Value<K, T>) => T; } & { map: (updater: (u: T) => T) => T; set: (newU: T) => T; }
+><T>(t: T) => {    const reduce = <U>(u: U, update: (u: U) => T) => {        const set = (newU: U) => Object.is(u, newU) ? t : update(newU);        return Object.assign(            <K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }),            { map: (updater: (u: U) => U) => set(updater(u)), set });    };    return reduce<T>(t, (t: T) => t);} : <T>(t: T) => <K extends keyof T>(key: K) => <K extends keyof Value<K, T>>(key: K) => <K extends keyof Value<K, Value<K, T>>>(key: K) => <K extends ???>(key: K) => ??? & ??? & { map: ???; set: ???; } & { map: (updater: (u: Value<K, Value<K, T>>) => Value<K, Value<K, T>>) => T; set: (newU: Value<K, Value<K, T>>) => T; } & { map: (updater: (u: Value<K, T>) => Value<K, T>) => T; set: (newU: Value<K, T>) => T; } & { map: (updater: (u: T) => T) => T; set: (newU: T) => T; }
 >t : T
 
     const reduce = <U>(u: U, update: (u: U) => T) => {
->reduce : <U>(u: U, update: (u: U) => T) => (<K extends Key<U>>(key: K) => (<K_1 extends keyof Value<K, U>>(key: K_1) => (<K_2 extends keyof Value<K_1, Value<K, U>>>(key: K_2) => (<K_3 extends keyof Value<K_2, Value<K_1, Value<K, U>>>>(key: K_3) => (<K_4 extends keyof Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>(key: K_4) => (<K_5 extends keyof Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>(key: K_5) => (<K_6 extends keyof Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>(key: K_6) => (<K_7 extends keyof Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>(key: K_7) => (<K_8 extends keyof Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>(key: K_8) => (<K_9 extends keyof Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>(key: K_9) => (<K_10 extends keyof Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>(key: K_10) => any & { map: (updater: (u: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; set: (newU: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; set: (newU: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; set: (newU: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; set: (newU: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; set: (newU: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; }) & { map: (updater: (u: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; set: (newU: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; }) & { map: (updater: (u: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; set: (newU: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; }) & { map: (updater: (u: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; set: (newU: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; }) & { map: (updater: (u: Value<K_2, Value<K_1, Value<K, U>>>) => Value<K_2, Value<K_1, Value<K, U>>>) => T; set: (newU: Value<K_2, Value<K_1, Value<K, U>>>) => T; }) & { map: (updater: (u: Value<K_1, Value<K, U>>) => Value<K_1, Value<K, U>>) => T; set: (newU: Value<K_1, Value<K, U>>) => T; }) & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; }) & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
-><U>(u: U, update: (u: U) => T) => {        const set = (newU: U) => Object.is(u, newU) ? t : update(newU);        return Object.assign(            <K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }),            { map: (updater: (u: U) => U) => set(updater(u)), set });    } : <U>(u: U, update: (u: U) => T) => (<K extends Key<U>>(key: K) => (<K_1 extends keyof Value<K, U>>(key: K_1) => (<K_2 extends keyof Value<K_1, Value<K, U>>>(key: K_2) => (<K_3 extends keyof Value<K_2, Value<K_1, Value<K, U>>>>(key: K_3) => (<K_4 extends keyof Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>(key: K_4) => (<K_5 extends keyof Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>(key: K_5) => (<K_6 extends keyof Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>(key: K_6) => (<K_7 extends keyof Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>(key: K_7) => (<K_8 extends keyof Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>(key: K_8) => (<K_9 extends keyof Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>(key: K_9) => (<K_10 extends keyof Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>(key: K_10) => any & { map: (updater: (u: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; set: (newU: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; set: (newU: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; set: (newU: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; set: (newU: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; set: (newU: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; }) & { map: (updater: (u: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; set: (newU: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; }) & { map: (updater: (u: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; set: (newU: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; }) & { map: (updater: (u: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; set: (newU: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; }) & { map: (updater: (u: Value<K_2, Value<K_1, Value<K, U>>>) => Value<K_2, Value<K_1, Value<K, U>>>) => T; set: (newU: Value<K_2, Value<K_1, Value<K, U>>>) => T; }) & { map: (updater: (u: Value<K_1, Value<K, U>>) => Value<K_1, Value<K, U>>) => T; set: (newU: Value<K_1, Value<K, U>>) => T; }) & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; }) & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
+>reduce : <U>(u: U, update: (u: U) => T) => <K extends keyof U>(key: K) => <K extends keyof Value<K, U>>(key: K) => <K extends keyof Value<K, Value<K, U>>>(key: K) => <K extends ???>(key: K) => ??? & ??? & { map: ???; set: ???; } & { map: (updater: (u: Value<K, Value<K, U>>) => Value<K, Value<K, U>>) => T; set: (newU: Value<K, Value<K, U>>) => T; } & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; } & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
+><U>(u: U, update: (u: U) => T) => {        const set = (newU: U) => Object.is(u, newU) ? t : update(newU);        return Object.assign(            <K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }),            { map: (updater: (u: U) => U) => set(updater(u)), set });    } : <U>(u: U, update: (u: U) => T) => <K extends keyof U>(key: K) => <K extends keyof Value<K, U>>(key: K) => <K extends keyof Value<K, Value<K, U>>>(key: K) => <K extends ???>(key: K) => ??? & ??? & { map: ???; set: ???; } & { map: (updater: (u: Value<K, Value<K, U>>) => Value<K, Value<K, U>>) => T; set: (newU: Value<K, Value<K, U>>) => T; } & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; } & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
 >u : U
 >update : (u: U) => T
 >u : U
@@= skipped -28, +28 lines =@@
 >newU : U
 
         return Object.assign(
->Object.assign(            <K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }),            { map: (updater: (u: U) => U) => set(updater(u)), set }) : (<K extends Key<U>>(key: K) => (<K_1 extends keyof Value<K, U>>(key: K_1) => (<K_2 extends keyof Value<K_1, Value<K, U>>>(key: K_2) => (<K_3 extends keyof Value<K_2, Value<K_1, Value<K, U>>>>(key: K_3) => (<K_4 extends keyof Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>(key: K_4) => (<K_5 extends keyof Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>(key: K_5) => (<K_6 extends keyof Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>(key: K_6) => (<K_7 extends keyof Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>(key: K_7) => (<K_8 extends keyof Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>(key: K_8) => (<K_9 extends keyof Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>(key: K_9) => (<K_10 extends keyof Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>(key: K_10) => any & { map: (updater: (u: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; set: (newU: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; set: (newU: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; set: (newU: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; set: (newU: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; set: (newU: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; }) & { map: (updater: (u: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; set: (newU: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; }) & { map: (updater: (u: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; set: (newU: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; }) & { map: (updater: (u: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; set: (newU: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; }) & { map: (updater: (u: Value<K_2, Value<K_1, Value<K, U>>>) => Value<K_2, Value<K_1, Value<K, U>>>) => T; set: (newU: Value<K_2, Value<K_1, Value<K, U>>>) => T; }) & { map: (updater: (u: Value<K_1, Value<K, U>>) => Value<K_1, Value<K, U>>) => T; set: (newU: Value<K_1, Value<K, U>>) => T; }) & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; }) & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
->Object.assign : { <T_1 extends {}, U_1>(target: T_1, source: U_1): T_1 & U_1; <T_1 extends {}, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V; <T_1 extends {}, U_1, V, W>(target: T_1, source1: U_1, source2: V, source3: W): T_1 & U_1 & V & W; (target: object, ...sources: any[]): any; }
+>Object.assign(            <K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }),            { map: (updater: (u: U) => U) => set(updater(u)), set }) : <K extends keyof U>(key: K) => <K extends keyof Value<K, U>>(key: K) => <K extends keyof Value<K, Value<K, U>>>(key: K) => <K extends keyof Value<K, Value<K, Value<K, U>>>>(key: K) => ??? & ??? & { map: (updater: ???) => T; set: (newU: Value<K, Value<K, Value<K, U>>>) => T; } & { map: (updater: (u: Value<K, Value<K, U>>) => Value<K, Value<K, U>>) => T; set: (newU: Value<K, Value<K, U>>) => T; } & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; } & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
+>Object.assign : { <T extends {}, U>(target: T, source: U): T & U; <T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V; <T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W; (target: object, ...sources: any[]): any; }
 >Object : ObjectConstructor
->assign : { <T_1 extends {}, U_1>(target: T_1, source: U_1): T_1 & U_1; <T_1 extends {}, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V; <T_1 extends {}, U_1, V, W>(target: T_1, source1: U_1, source2: V, source3: W): T_1 & U_1 & V & W; (target: object, ...sources: any[]): any; }
+>assign : { <T extends {}, U>(target: T, source: U): T & U; <T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V; <T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W; (target: object, ...sources: any[]): any; }
 
             <K extends Key<U>>(key: K) =>
-><K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }) : <K extends Key<U>>(key: K) => (<K_1 extends keyof Value<K, U>>(key: K_1) => (<K_2 extends keyof Value<K_1, Value<K, U>>>(key: K_2) => (<K_3 extends keyof Value<K_2, Value<K_1, Value<K, U>>>>(key: K_3) => (<K_4 extends keyof Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>(key: K_4) => (<K_5 extends keyof Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>(key: K_5) => (<K_6 extends keyof Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>(key: K_6) => (<K_7 extends keyof Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>(key: K_7) => (<K_8 extends keyof Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>(key: K_8) => (<K_9 extends keyof Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>(key: K_9) => (<K_10 extends keyof Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>(key: K_10) => any & { map: (updater: (u: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; set: (newU: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; set: (newU: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; set: (newU: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; set: (newU: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; set: (newU: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; }) & { map: (updater: (u: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; set: (newU: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; }) & { map: (updater: (u: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; set: (newU: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; }) & { map: (updater: (u: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; set: (newU: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; }) & { map: (updater: (u: Value<K_2, Value<K_1, Value<K, U>>>) => Value<K_2, Value<K_1, Value<K, U>>>) => T; set: (newU: Value<K_2, Value<K_1, Value<K, U>>>) => T; }) & { map: (updater: (u: Value<K_1, Value<K, U>>) => Value<K_1, Value<K, U>>) => T; set: (newU: Value<K_1, Value<K, U>>) => T; }) & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; }
+><K extends Key<U>>(key: K) =>                reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }) : <K extends keyof U>(key: K) => <K extends keyof Value<K, U>>(key: K) => <K extends keyof Value<K, Value<K, U>>>(key: K) => <K extends keyof Value<K, Value<K, Value<K, U>>>>(key: K) => <K extends ???>(key: K) => ??? & ??? & { map: ???; set: ???; } & { map: (updater: (u: Value<K, Value<K, Value<K, U>>>) => Value<K, Value<K, Value<K, U>>>) => T; set: (newU: Value<K, Value<K, Value<K, U>>>) => T; } & { map: (updater: (u: Value<K, Value<K, U>>) => Value<K, Value<K, U>>) => T; set: (newU: Value<K, Value<K, U>>) => T; } & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; }
 >key : K
 
                 reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {
->reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }) : (<K extends keyof Value<K_1, U>>(key: K) => (<K_2 extends keyof Value<K, Value<K_1, U>>>(key: K_2) => (<K_3 extends keyof Value<K_2, Value<K, Value<K_1, U>>>>(key: K_3) => (<K_4 extends keyof Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>(key: K_4) => (<K_5 extends keyof Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>(key: K_5) => (<K_6 extends keyof Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>(key: K_6) => (<K_7 extends keyof Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>(key: K_7) => (<K_8 extends keyof Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>(key: K_8) => (<K_9 extends keyof Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>(key: K_9) => (<K_10 extends keyof Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>>(key: K_10) => (<K_11 extends keyof Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>>>(key: K_11) => any & { map: (updater: (u: Value<K_11, Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>>>) => Value<K_11, Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>>>) => T; set: (newU: Value<K_11, Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>>) => Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>>) => T; set: (newU: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>) => Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>) => T; set: (newU: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>) => Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>) => T; set: (newU: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>) => Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>) => T; set: (newU: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>) => Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>) => T; set: (newU: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>>) => T; }) & { map: (updater: (u: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>) => Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>) => T; set: (newU: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>>) => T; }) & { map: (updater: (u: Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>) => Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>) => T; set: (newU: Value<K_4, Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>>) => T; }) & { map: (updater: (u: Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>) => Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>) => T; set: (newU: Value<K_3, Value<K_2, Value<K, Value<K_1, U>>>>) => T; }) & { map: (updater: (u: Value<K_2, Value<K, Value<K_1, U>>>) => Value<K_2, Value<K, Value<K_1, U>>>) => T; set: (newU: Value<K_2, Value<K, Value<K_1, U>>>) => T; }) & { map: (updater: (u: Value<K, Value<K_1, U>>) => Value<K, Value<K_1, U>>) => T; set: (newU: Value<K, Value<K_1, U>>) => T; }) & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; }
->reduce : <U>(u: U, update: (u: U) => T) => (<K extends Key<U>>(key: K) => (<K_1 extends keyof Value<K, U>>(key: K_1) => (<K_2 extends keyof Value<K_1, Value<K, U>>>(key: K_2) => (<K_3 extends keyof Value<K_2, Value<K_1, Value<K, U>>>>(key: K_3) => (<K_4 extends keyof Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>(key: K_4) => (<K_5 extends keyof Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>(key: K_5) => (<K_6 extends keyof Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>(key: K_6) => (<K_7 extends keyof Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>(key: K_7) => (<K_8 extends keyof Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>(key: K_8) => (<K_9 extends keyof Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>(key: K_9) => (<K_10 extends keyof Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>(key: K_10) => any & { map: (updater: (u: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; set: (newU: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; set: (newU: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; set: (newU: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; set: (newU: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; set: (newU: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; }) & { map: (updater: (u: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; set: (newU: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; }) & { map: (updater: (u: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; set: (newU: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; }) & { map: (updater: (u: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; set: (newU: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; }) & { map: (updater: (u: Value<K_2, Value<K_1, Value<K, U>>>) => Value<K_2, Value<K_1, Value<K, U>>>) => T; set: (newU: Value<K_2, Value<K_1, Value<K, U>>>) => T; }) & { map: (updater: (u: Value<K_1, Value<K, U>>) => Value<K_1, Value<K, U>>) => T; set: (newU: Value<K_1, Value<K, U>>) => T; }) & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; }) & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
+>reduce<Value<K, U>>(u[key as keyof U] as Value<K, U>, (v: Value<K, U>) => {                    return update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }));                }) : <K extends keyof Value<K, U>>(key: K) => <K extends keyof Value<K, Value<K, U>>>(key: K) => <K extends keyof Value<K, Value<K, Value<K, U>>>>(key: K) => <K extends keyof Value<K, Value<K, Value<K, Value<K, U>>>>>(key: K) => ??? & ??? & { map: (updater: ???) => T; set: (newU: Value<K, Value<K, Value<K, Value<K, U>>>>) => T; } & { map: (updater: (u: Value<K, Value<K, Value<K, U>>>) => Value<K, Value<K, Value<K, U>>>) => T; set: (newU: Value<K, Value<K, Value<K, U>>>) => T; } & { map: (updater: (u: Value<K, Value<K, U>>) => Value<K, Value<K, U>>) => T; set: (newU: Value<K, Value<K, U>>) => T; } & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; }
+>reduce : <U>(u: U, update: (u: U) => T) => <K extends keyof U>(key: K) => <K extends keyof Value<K, U>>(key: K) => <K extends keyof Value<K, Value<K, U>>>(key: K) => <K extends ???>(key: K) => ??? & ??? & { map: ???; set: ???; } & { map: (updater: (u: Value<K, Value<K, U>>) => Value<K, Value<K, U>>) => T; set: (newU: Value<K, Value<K, U>>) => T; } & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; } & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
 >u[key as keyof U] as Value<K, U> : Value<K, U>
 >u[key as keyof U] : U[keyof U]
 >u : U
@@= skipped -24, +24 lines =@@
 >update(Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v })) : T
 >update : (u: U) => T
 >Object.assign(Array.isArray(u) ? [] : {}, u, { [key]: v }) : U & { [x: string]: Value<K, U>; }
->Object.assign : { <T_1 extends {}, U_1>(target: T_1, source: U_1): T_1 & U_1; <T_1 extends {}, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V; <T_1 extends {}, U_1, V, W>(target: T_1, source1: U_1, source2: V, source3: W): T_1 & U_1 & V & W; (target: object, ...sources: any[]): any; }
+>Object.assign : { <T extends {}, U>(target: T, source: U): T & U; <T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V; <T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W; (target: object, ...sources: any[]): any; }
 >Object : ObjectConstructor
->assign : { <T_1 extends {}, U_1>(target: T_1, source: U_1): T_1 & U_1; <T_1 extends {}, U_1, V>(target: T_1, source1: U_1, source2: V): T_1 & U_1 & V; <T_1 extends {}, U_1, V, W>(target: T_1, source1: U_1, source2: V, source3: W): T_1 & U_1 & V & W; (target: object, ...sources: any[]): any; }
+>assign : { <T extends {}, U>(target: T, source: U): T & U; <T extends {}, U, V>(target: T, source1: U, source2: V): T & U & V; <T extends {}, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W; (target: object, ...sources: any[]): any; }
 >Array.isArray(u) ? [] : {} : undefined[] | {}
 >Array.isArray(u) : boolean
 >Array.isArray : (arg: any) => arg is any[]
@@= skipped -33, +33 lines =@@
 
     };
     return reduce<T>(t, (t: T) => t);
->reduce<T>(t, (t: T) => t) : (<K extends keyof T>(key: K) => (<K_1 extends keyof Value<K, T>>(key: K_1) => (<K_2 extends keyof Value<K_1, Value<K, T>>>(key: K_2) => (<K_3 extends keyof Value<K_2, Value<K_1, Value<K, T>>>>(key: K_3) => (<K_4 extends keyof Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>(key: K_4) => (<K_5 extends keyof Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>(key: K_5) => (<K_6 extends keyof Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>(key: K_6) => (<K_7 extends keyof Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>(key: K_7) => (<K_8 extends keyof Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>(key: K_8) => (<K_9 extends keyof Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>(key: K_9) => (<K_10 extends keyof Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>(key: K_10) => any & { map: (updater: (u: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>) => Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>) => T; set: (newU: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>) => Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>) => T; set: (newU: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>) => Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>) => T; set: (newU: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>) => Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>) => T; set: (newU: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>) => Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>) => T; set: (newU: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>>) => T; }) & { map: (updater: (u: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>) => Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>) => T; set: (newU: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>>) => T; }) & { map: (updater: (u: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>) => Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>) => T; set: (newU: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>>) => T; }) & { map: (updater: (u: Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>) => Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>) => T; set: (newU: Value<K_3, Value<K_2, Value<K_1, Value<K, T>>>>) => T; }) & { map: (updater: (u: Value<K_2, Value<K_1, Value<K, T>>>) => Value<K_2, Value<K_1, Value<K, T>>>) => T; set: (newU: Value<K_2, Value<K_1, Value<K, T>>>) => T; }) & { map: (updater: (u: Value<K_1, Value<K, T>>) => Value<K_1, Value<K, T>>) => T; set: (newU: Value<K_1, Value<K, T>>) => T; }) & { map: (updater: (u: Value<K, T>) => Value<K, T>) => T; set: (newU: Value<K, T>) => T; }) & { map: (updater: (u: T) => T) => T; set: (newU: T) => T; }
->reduce : <U>(u: U, update: (u: U) => T) => (<K extends Key<U>>(key: K) => (<K_1 extends keyof Value<K, U>>(key: K_1) => (<K_2 extends keyof Value<K_1, Value<K, U>>>(key: K_2) => (<K_3 extends keyof Value<K_2, Value<K_1, Value<K, U>>>>(key: K_3) => (<K_4 extends keyof Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>(key: K_4) => (<K_5 extends keyof Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>(key: K_5) => (<K_6 extends keyof Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>(key: K_6) => (<K_7 extends keyof Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>(key: K_7) => (<K_8 extends keyof Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>(key: K_8) => (<K_9 extends keyof Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>(key: K_9) => (<K_10 extends keyof Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>(key: K_10) => any & { map: (updater: (u: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; set: (newU: Value<K_10, Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; set: (newU: Value<K_9, Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; set: (newU: Value<K_8, Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; set: (newU: Value<K_7, Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>>) => T; }) & { map: (updater: (u: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; set: (newU: Value<K_6, Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>>) => T; }) & { map: (updater: (u: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; set: (newU: Value<K_5, Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>>) => T; }) & { map: (updater: (u: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; set: (newU: Value<K_4, Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>>) => T; }) & { map: (updater: (u: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; set: (newU: Value<K_3, Value<K_2, Value<K_1, Value<K, U>>>>) => T; }) & { map: (updater: (u: Value<K_2, Value<K_1, Value<K, U>>>) => Value<K_2, Value<K_1, Value<K, U>>>) => T; set: (newU: Value<K_2, Value<K_1, Value<K, U>>>) => T; }) & { map: (updater: (u: Value<K_1, Value<K, U>>) => Value<K_1, Value<K, U>>) => T; set: (newU: Value<K_1, Value<K, U>>) => T; }) & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; }) & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
+>reduce<T>(t, (t: T) => t) : <K extends keyof T>(key: K) => <K extends keyof Value<K, T>>(key: K) => <K extends keyof Value<K, Value<K, T>>>(key: K) => <K extends keyof Value<K, Value<K, Value<K, T>>>>(key: K) => ??? & ??? & { map: (updater: ???) => T; set: (newU: Value<K, Value<K, Value<K, T>>>) => T; } & { map: (updater: (u: Value<K, Value<K, T>>) => Value<K, Value<K, T>>) => T; set: (newU: Value<K, Value<K, T>>) => T; } & { map: (updater: (u: Value<K, T>) => Value<K, T>) => T; set: (newU: Value<K, T>) => T; } & { map: (updater: (u: T) => T) => T; set: (newU: T) => T; }
+>reduce : <U>(u: U, update: (u: U) => T) => <K extends keyof U>(key: K) => <K extends keyof Value<K, U>>(key: K) => <K extends keyof Value<K, Value<K, U>>>(key: K) => <K extends ???>(key: K) => ??? & ??? & { map: ???; set: ???; } & { map: (updater: (u: Value<K, Value<K, U>>) => Value<K, Value<K, U>>) => T; set: (newU: Value<K, Value<K, U>>) => T; } & { map: (updater: (u: Value<K, U>) => Value<K, U>) => T; set: (newU: Value<K, U>) => T; } & { map: (updater: (u: U) => U) => T; set: (newU: U) => T; }
 >t : T
 >(t: T) => t : (t: T) => T
 >t : T
@@= skipped -12, +12 lines =@@
 // example from https://github.com/microsoft/TypeScript/issues/31605
 
 export const testRecFun = <T extends Object>(parent: T) => {
->testRecFun : <T extends Object>(parent: T) => { result: T; deeper: <U extends Object>(child: U) => { result: T & U; deeper: <U_1 extends Object>(child: U_1) => { result: T & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: T & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: T & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: T & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
-><T extends Object>(parent: T) => {    return {        result: parent,        deeper: <U extends Object>(child: U) =>            testRecFun<T & U>({ ...parent, ...child })    };} : <T extends Object>(parent: T) => { result: T; deeper: <U extends Object>(child: U) => { result: T & U; deeper: <U_1 extends Object>(child: U_1) => { result: T & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: T & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: T & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: T & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
+>testRecFun : <T extends Object>(parent: T) => { result: T; deeper: <U extends Object>(child: U) => { result: T & U; deeper: <U extends Object>(child: U) => { result: T & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U; deeper: <U extends ???>(child: U) => ???; }; }; }; }
+><T extends Object>(parent: T) => {    return {        result: parent,        deeper: <U extends Object>(child: U) =>            testRecFun<T & U>({ ...parent, ...child })    };} : <T extends Object>(parent: T) => { result: T; deeper: <U extends Object>(child: U) => { result: T & U; deeper: <U extends Object>(child: U) => { result: T & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U; deeper: <U extends ???>(child: U) => ???; }; }; }; }
 >parent : T
 
     return {
->{        result: parent,        deeper: <U extends Object>(child: U) =>            testRecFun<T & U>({ ...parent, ...child })    } : { result: T; deeper: <U extends Object>(child: U) => { result: T & U; deeper: <U_1 extends Object>(child: U_1) => { result: T & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: T & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: T & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: T & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
+>{        result: parent,        deeper: <U extends Object>(child: U) =>            testRecFun<T & U>({ ...parent, ...child })    } : { result: T; deeper: <U extends Object>(child: U) => { result: T & U; deeper: <U extends Object>(child: U) => { result: T & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U & U; deeper: ???; }; }; }; }; }
 
         result: parent,
 >result : T
 >parent : T
 
         deeper: <U extends Object>(child: U) =>
->deeper : <U extends Object>(child: U) => { result: T & U; deeper: <U_1 extends Object>(child: U_1) => { result: T & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: T & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: T & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: T & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9 & U_10; deeper: any; }; }; }; }; }; }; }; }; }; }; }
-><U extends Object>(child: U) =>            testRecFun<T & U>({ ...parent, ...child }) : <U extends Object>(child: U) => { result: T & U; deeper: <U_1 extends Object>(child: U_1) => { result: T & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: T & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: T & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: T & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9 & U_10; deeper: any; }; }; }; }; }; }; }; }; }; }; }
+>deeper : <U extends Object>(child: U) => { result: T & U; deeper: <U extends Object>(child: U) => { result: T & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U & U; deeper: <U extends ???>(child: U) => ???; }; }; }; }
+><U extends Object>(child: U) =>            testRecFun<T & U>({ ...parent, ...child }) : <U extends Object>(child: U) => { result: T & U; deeper: <U extends Object>(child: U) => { result: T & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U & U; deeper: <U extends ???>(child: U) => ???; }; }; }; }
 >child : U
 
             testRecFun<T & U>({ ...parent, ...child })
->testRecFun<T & U>({ ...parent, ...child }) : { result: T & U; deeper: <U_1 extends Object>(child: U_1) => { result: T & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: T & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: T & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: T & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9 & U_10; deeper: <U_11 extends Object>(child: U_11) => any; }; }; }; }; }; }; }; }; }; }; }
->testRecFun : <T extends Object>(parent: T) => { result: T; deeper: <U extends Object>(child: U) => { result: T & U; deeper: <U_1 extends Object>(child: U_1) => { result: T & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: T & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: T & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: T & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
+>testRecFun<T & U>({ ...parent, ...child }) : { result: T & U; deeper: <U extends Object>(child: U) => { result: T & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U & U & U; deeper: ???; }; }; }; }; }
+>testRecFun : <T extends Object>(parent: T) => { result: T; deeper: <U extends Object>(child: U) => { result: T & U; deeper: <U extends Object>(child: U) => { result: T & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U; deeper: <U extends ???>(child: U) => ???; }; }; }; }
 >{ ...parent, ...child } : T & U
 >parent : T
 >child : U
@@= skipped -28, +28 lines =@@
 
 
 let p1 = testRecFun({ one: '1' })
->p1 : { result: { one: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
->testRecFun({ one: '1' }) : { result: { one: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
->testRecFun : <T extends Object>(parent: T) => { result: T; deeper: <U extends Object>(child: U) => { result: T & U; deeper: <U_1 extends Object>(child: U_1) => { result: T & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: T & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: T & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: T & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: T & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
+>p1 : { result: { one: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & U & U & U & U; deeper: ???; }; }; }; }; }
+>testRecFun({ one: '1' }) : { result: { one: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & U & U & U & U; deeper: ???; }; }; }; }; }
+>testRecFun : <T extends Object>(parent: T) => { result: T; deeper: <U extends Object>(child: U) => { result: T & U; deeper: <U extends Object>(child: U) => { result: T & U & U; deeper: <U extends Object>(child: U) => { result: T & U & U & U; deeper: <U extends ???>(child: U) => ???; }; }; }; }
 >{ one: '1' } : { one: string; }
 >one : string
 >'1' : "1"
@@= skipped -11, +11 lines =@@
 >void p1.result.one : undefined
 >p1.result.one : string
 >p1.result : { one: string; }
->p1 : { result: { one: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
+>p1 : { result: { one: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & U & U & U & U; deeper: ???; }; }; }; }; }
 >result : { one: string; }
 >one : string
 
 let p2 = p1.deeper({ two: '2' })
->p2 : { result: { one: string; } & { two: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
->p1.deeper({ two: '2' }) : { result: { one: string; } & { two: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
->p1.deeper : <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9 & U_10; deeper: any; }; }; }; }; }; }; }; }; }; }; }
->p1 : { result: { one: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
->deeper : <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => { result: { one: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9 & U_10; deeper: any; }; }; }; }; }; }; }; }; }; }; }
+>p2 : { result: { one: string; } & { two: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & U & U & U & U; deeper: ???; }; }; }; }; }
+>p1.deeper({ two: '2' }) : { result: { one: string; } & { two: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & U & U & U & U; deeper: ???; }; }; }; }; }
+>p1.deeper : <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & U & U & U & U; deeper: <U extends ???>(child: U) => ???; }; }; }; }
+>p1 : { result: { one: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & U & U & U & U; deeper: ???; }; }; }; }; }
+>deeper : <U extends Object>(child: U) => { result: { one: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & U & U & U & U; deeper: <U extends ???>(child: U) => ???; }; }; }; }
 >{ two: '2' } : { two: string; }
 >two : string
 >'2' : "2"
@@= skipped -18, +18 lines =@@
 >void p2.result.one : undefined
 >p2.result.one : string
 >p2.result : { one: string; } & { two: string; }
->p2 : { result: { one: string; } & { two: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
+>p2 : { result: { one: string; } & { two: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & U & U & U & U; deeper: ???; }; }; }; }; }
 >result : { one: string; } & { two: string; }
 >one : string
 
@@= skipped -8, +8 lines =@@
 >void p2.result.two : undefined
 >p2.result.two : string
 >p2.result : { one: string; } & { two: string; }
->p2 : { result: { one: string; } & { two: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
+>p2 : { result: { one: string; } & { two: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & U & U & U & U; deeper: ???; }; }; }; }; }
 >result : { one: string; } & { two: string; }
 >two : string
 
 let p3 = p2.deeper({ three: '3' })
->p3 : { result: { one: string; } & { two: string; } & { three: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
->p2.deeper({ three: '3' }) : { result: { one: string; } & { two: string; } & { three: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
->p2.deeper : <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9 & U_10; deeper: any; }; }; }; }; }; }; }; }; }; }; }
->p2 : { result: { one: string; } & { two: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
->deeper : <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => { result: { one: string; } & { two: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9 & U_10; deeper: any; }; }; }; }; }; }; }; }; }; }; }
+>p3 : { result: { one: string; } & { two: string; } & { three: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & ??? & U & U & U & U; deeper: ???; }; }; }; }; }
+>p2.deeper({ three: '3' }) : { result: { one: string; } & { two: string; } & { three: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & ??? & U & U & U & U; deeper: ???; }; }; }; }; }
+>p2.deeper : <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & U & U & U & U; deeper: <U extends ???>(child: U) => ???; }; }; }; }
+>p2 : { result: { one: string; } & { two: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & U & U & U & U; deeper: ???; }; }; }; }; }
+>deeper : <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & U & U & U & U; deeper: <U extends ???>(child: U) => ???; }; }; }; }
 >{ three: '3' } : { three: string; }
 >three : string
 >'3' : "3"
@@= skipped -18, +18 lines =@@
 >void p3.result.one : undefined
 >p3.result.one : string
 >p3.result : { one: string; } & { two: string; } & { three: string; }
->p3 : { result: { one: string; } & { two: string; } & { three: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
+>p3 : { result: { one: string; } & { two: string; } & { three: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & ??? & U & U & U & U; deeper: ???; }; }; }; }; }
 >result : { one: string; } & { two: string; } & { three: string; }
 >one : string
 
@@= skipped -8, +8 lines =@@
 >void p3.result.two : undefined
 >p3.result.two : string
 >p3.result : { one: string; } & { two: string; } & { three: string; }
->p3 : { result: { one: string; } & { two: string; } & { three: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
+>p3 : { result: { one: string; } & { two: string; } & { three: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & ??? & U & U & U & U; deeper: ???; }; }; }; }; }
 >result : { one: string; } & { two: string; } & { three: string; }
 >two : string
 
@@= skipped -8, +8 lines =@@
 >void p3.result.three : undefined
 >p3.result.three : string
 >p3.result : { one: string; } & { two: string; } & { three: string; }
->p3 : { result: { one: string; } & { two: string; } & { three: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U; deeper: <U_1 extends Object>(child: U_1) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1; deeper: <U_2 extends Object>(child: U_2) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2; deeper: <U_3 extends Object>(child: U_3) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3; deeper: <U_4 extends Object>(child: U_4) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4; deeper: <U_5 extends Object>(child: U_5) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5; deeper: <U_6 extends Object>(child: U_6) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6; deeper: <U_7 extends Object>(child: U_7) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7; deeper: <U_8 extends Object>(child: U_8) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8; deeper: <U_9 extends Object>(child: U_9) => { result: { one: string; } & { two: string; } & { three: string; } & U & U_1 & U_2 & U_3 & U_4 & U_5 & U_6 & U_7 & U_8 & U_9; deeper: <U_10 extends Object>(child: U_10) => any; }; }; }; }; }; }; }; }; }; }; }
+>p3 : { result: { one: string; } & { two: string; } & { three: string; }; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U & U; deeper: <U extends Object>(child: U) => { result: { one: string; } & { two: string; } & { three: string; } & U & U & U; deeper: <U extends Object>(child: U) => { result: ??? & ??? & ??? & U & U & U & U; deeper: ???; }; }; }; }; }
 >result : { one: string; } & { two: string; } & { three: string; }
 >three : string
 

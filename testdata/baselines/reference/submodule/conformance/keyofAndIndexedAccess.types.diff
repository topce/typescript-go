--- old.keyofAndIndexedAccess.types
+++ new.keyofAndIndexedAccess.types
@@= skipped -38, +38 lines =@@
 >Options : Options
 
     visible: "yes" | "no";
->visible : "yes" | "no"
+>visible : "no" | "yes"
 }
 
 type Dictionary<T> = { [x: string]: T };
@@= skipped -21, +21 lines =@@
 >K00 : string | number | symbol
 
 type K01 = keyof string;  // "toString" | "charAt" | ...
->K01 : number | "length" | "toString" | "concat" | "slice" | "indexOf" | "lastIndexOf" | "charAt" | "charCodeAt" | "localeCompare" | "match" | "replace" | "search" | "split" | "substring" | "toLowerCase" | "toLocaleLowerCase" | "toUpperCase" | "toLocaleUpperCase" | "trim" | "substr" | "valueOf"
+>K01 : number | "charAt" | "charCodeAt" | "concat" | "indexOf" | "lastIndexOf" | "length" | "localeCompare" | "match" | "replace" | "search" | "slice" | "split" | "substr" | "substring" | "toLocaleLowerCase" | "toLocaleUpperCase" | "toLowerCase" | "toString" | "toUpperCase" | "trim" | "valueOf"
 
 type K02 = keyof number;  // "toString" | "toFixed" | "toExponential" | ...
->K02 : "toString" | "toLocaleString" | "toFixed" | "toExponential" | "toPrecision" | "valueOf"
+>K02 : "toExponential" | "toFixed" | "toLocaleString" | "toPrecision" | "toString" | "valueOf"
 
 type K03 = keyof boolean;  // "valueOf"
 >K03 : "valueOf"
@@= skipped -39, +39 lines =@@
 >K14 : keyof Object
 
 type K15 = keyof E;  // "toString" | "toFixed" | "toExponential" | ...
->K15 : "toString" | "toLocaleString" | "toFixed" | "toExponential" | "toPrecision" | "valueOf"
+>K15 : "toExponential" | "toFixed" | "toLocaleString" | "toPrecision" | "toString" | "valueOf"
 
 type K16 = keyof [string, number];  // "0" | "1" | "length" | "toString" | ...
 >K16 : keyof [string, number]
@@= skipped -9, +9 lines =@@
 >K17 : "name"
 
 type K18 = keyof (Shape & Item);  // "name" | "width" | "height" | "visible" | "price"
->K18 : "name" | "width" | "height" | "visible" | "price"
+>K18 : "height" | "name" | "price" | "visible" | "width"
 
 type K19 = keyof NumericallyIndexed<Shape> // never
 >K19 : number
@@= skipped -59, +59 lines =@@
 >Q36 : number
 
 type Q40 = (Shape | Options)["visible"];  // boolean | "yes" | "no"
->Q40 : boolean | "yes" | "no"
+>Q40 : "no" | "yes" | boolean
 
 type Q41 = (Shape & Options)["visible"];  // true & "yes" | true & "no" | false & "yes" | false & "no"
 >Q41 : never
@@= skipped -59, +59 lines =@@
 >getProperty(shape, cond ? "width" : "height") : number
 >getProperty : <T, K extends keyof T>(obj: T, key: K) => T[K]
 >shape : Shape
->cond ? "width" : "height" : "width" | "height"
+>cond ? "width" : "height" : "height" | "width"
 >cond : boolean
 >"width" : "width"
 >"height" : "height"
@@= skipped -26, +26 lines =@@
 >setProperty(shape, cond ? "width" : "height", 10) : void
 >setProperty : <T, K extends keyof T>(obj: T, key: K, value: T[K]) => void
 >shape : Shape
->cond ? "width" : "height" : "width" | "height"
+>cond ? "width" : "height" : "height" | "width"
 >cond : boolean
 >"width" : "width"
 >"height" : "height"
@@= skipped -140, +140 lines =@@
 >component.getProperty : <K extends keyof Shape>(key: K) => Shape[K]
 >component : Component<Shape>
 >getProperty : <K extends keyof Shape>(key: K) => Shape[K]
->cond ? "width" : "height" : "width" | "height"
+>cond ? "width" : "height" : "height" | "width"
 >cond : boolean
 >"width" : "width"
 >"height" : "height"
@@= skipped -29, +29 lines =@@
 >component.setProperty : <K extends keyof Shape>(key: K, value: Shape[K]) => void
 >component : Component<Shape>
 >setProperty : <K extends keyof Shape>(key: K, value: Shape[K]) => void
->cond ? "width" : "height" : "width" | "height"
+>cond ? "width" : "height" : "height" | "width"
 >cond : boolean
 >"width" : "width"
 >"height" : "height"
@@= skipped -87, +87 lines =@@
 }
 
 function f32<K extends "width" | "height">(key: K) {
->f32 : <K extends "width" | "height">(key: K) => Shape[K]
+>f32 : <K extends "height" | "width">(key: K) => Shape[K]
 >key : K
 
     const shape: Shape = { name: "foo", width: 5, height: 10, visible: true };
@@= skipped -29, +29 lines =@@
     let name = getProperty(shape, "name");
 >name : S["name"]
 >getProperty(shape, "name") : S["name"]
->getProperty : <T, K_1 extends keyof T>(obj: T, key: K_1) => T[K_1]
+>getProperty : <T, K extends keyof T>(obj: T, key: K) => T[K]
 >shape : S
 >"name" : "name"
 
     let prop = getProperty(shape, key);
 >prop : S[K]
 >getProperty(shape, key) : S[K]
->getProperty : <T, K_1 extends keyof T>(obj: T, key: K_1) => T[K_1]
+>getProperty : <T, K extends keyof T>(obj: T, key: K) => T[K]
 >shape : S
 >key : K
 
@@= skipped -228, +228 lines =@@
 }
 
 function f70(func: <T, U>(k1: keyof (T | U), k2: keyof (T & U)) => void) {
->f70 : (func: <T, U>(k1: keyof (T | U), k2: keyof (T & U)) => void) => void
->func : <T, U>(k1: keyof (T | U), k2: keyof (T & U)) => void
+>f70 : (func: <T, U>(k1: keyof T & keyof U, k2: keyof T | keyof U) => void) => void
+>func : <T, U>(k1: keyof T & keyof U, k2: keyof T | keyof U) => void
 >k1 : keyof T & keyof U
 >k2 : keyof T | keyof U
 
     func<{ a: any, b: any }, { a: any, c: any }>('a', 'a');
 >func<{ a: any, b: any }, { a: any, c: any }>('a', 'a') : void
->func : <T, U>(k1: keyof (T | U), k2: keyof (T & U)) => void
+>func : <T, U>(k1: keyof T & keyof U, k2: keyof T | keyof U) => void
 >a : any
 >b : any
 >a : any
@@= skipped -17, +17 lines =@@
 
     func<{ a: any, b: any }, { a: any, c: any }>('a', 'b');
 >func<{ a: any, b: any }, { a: any, c: any }>('a', 'b') : void
->func : <T, U>(k1: keyof (T | U), k2: keyof (T & U)) => void
+>func : <T, U>(k1: keyof T & keyof U, k2: keyof T | keyof U) => void
 >a : any
 >b : any
 >a : any
@@= skipped -10, +10 lines =@@
 
     func<{ a: any, b: any }, { a: any, c: any }>('a', 'c');
 >func<{ a: any, b: any }, { a: any, c: any }>('a', 'c') : void
->func : <T, U>(k1: keyof (T | U), k2: keyof (T & U)) => void
+>func : <T, U>(k1: keyof T & keyof U, k2: keyof T | keyof U) => void
 >a : any
 >b : any
 >a : any
@@= skipped -45, +45 lines =@@
 }
 
 function f72(func: <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => (T & U)[K]) {
->f72 : (func: <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => (T & U)[K]) => void
->func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => (T & U)[K]
+>f72 : (func: <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => T & U[K]) => void
+>func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => T & U[K]
 >x : T
 >y : U
 >k : K
@@= skipped -9, +9 lines =@@
     let a = func({ a: 1, b: "hello" }, { c: true }, 'a');  // number
 >a : number
 >func({ a: 1, b: "hello" }, { c: true }, 'a') : number
->func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => (T & U)[K]
+>func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => T & U[K]
 >{ a: 1, b: "hello" } : { a: number; b: string; }
 >a : number
 >1 : 1
@@= skipped -14, +14 lines =@@
     let b = func({ a: 1, b: "hello" }, { c: true }, 'b');  // string
 >b : string
 >func({ a: 1, b: "hello" }, { c: true }, 'b') : string
->func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => (T & U)[K]
+>func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => T & U[K]
 >{ a: 1, b: "hello" } : { a: number; b: string; }
 >a : number
 >1 : 1
@@= skipped -14, +14 lines =@@
     let c = func({ a: 1, b: "hello" }, { c: true }, 'c');  // boolean
 >c : boolean
 >func({ a: 1, b: "hello" }, { c: true }, 'c') : boolean
->func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => (T & U)[K]
+>func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => T & U[K]
 >{ a: 1, b: "hello" } : { a: number; b: string; }
 >a : number
 >1 : 1
@@= skipped -13, +13 lines =@@
 }
 
 function f73(func: <T, U, K extends keyof (T & U)>(x: T, y: U, k: K) => (T & U)[K]) {
->f73 : (func: <T, U, K extends keyof (T & U)>(x: T, y: U, k: K) => (T & U)[K]) => void
->func : <T, U, K extends keyof (T & U)>(x: T, y: U, k: K) => (T & U)[K]
+>f73 : (func: <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => T & U[K]) => void
+>func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => T & U[K]
 >x : T
 >y : U
 >k : K
@@= skipped -9, +9 lines =@@
     let a = func({ a: 1, b: "hello" }, { c: true }, 'a');  // number
 >a : number
 >func({ a: 1, b: "hello" }, { c: true }, 'a') : number
->func : <T, U, K extends keyof (T & U)>(x: T, y: U, k: K) => (T & U)[K]
+>func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => T & U[K]
 >{ a: 1, b: "hello" } : { a: number; b: string; }
 >a : number
 >1 : 1
@@= skipped -14, +14 lines =@@
     let b = func({ a: 1, b: "hello" }, { c: true }, 'b');  // string
 >b : string
 >func({ a: 1, b: "hello" }, { c: true }, 'b') : string
->func : <T, U, K extends keyof (T & U)>(x: T, y: U, k: K) => (T & U)[K]
+>func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => T & U[K]
 >{ a: 1, b: "hello" } : { a: number; b: string; }
 >a : number
 >1 : 1
@@= skipped -14, +14 lines =@@
     let c = func({ a: 1, b: "hello" }, { c: true }, 'c');  // boolean
 >c : boolean
 >func({ a: 1, b: "hello" }, { c: true }, 'c') : boolean
->func : <T, U, K extends keyof (T & U)>(x: T, y: U, k: K) => (T & U)[K]
+>func : <T, U, K extends keyof T | keyof U>(x: T, y: U, k: K) => T & U[K]
 >{ a: 1, b: "hello" } : { a: number; b: string; }
 >a : number
 >1 : 1
@@= skipped -13, +13 lines =@@
 }
 
 function f74(func: <T, U, K extends keyof (T | U)>(x: T, y: U, k: K) => (T | U)[K]) {
->f74 : (func: <T, U, K extends keyof (T | U)>(x: T, y: U, k: K) => (T | U)[K]) => void
->func : <T, U, K extends keyof (T | U)>(x: T, y: U, k: K) => (T | U)[K]
+>f74 : (func: <T, U, K extends keyof T & keyof U>(x: T, y: U, k: K) => T | U[K]) => void
+>func : <T, U, K extends keyof T & keyof U>(x: T, y: U, k: K) => T | U[K]
 >x : T
 >y : U
 >k : K
@@= skipped -9, +9 lines =@@
     let a = func({ a: 1, b: "hello" }, { a: 2, b: true }, 'a');  // number
 >a : number
 >func({ a: 1, b: "hello" }, { a: 2, b: true }, 'a') : number
->func : <T, U, K extends keyof (T | U)>(x: T, y: U, k: K) => (T | U)[K]
+>func : <T, U, K extends keyof T & keyof U>(x: T, y: U, k: K) => T | U[K]
 >{ a: 1, b: "hello" } : { a: number; b: string; }
 >a : number
 >1 : 1
@@= skipped -16, +16 lines =@@
     let b = func({ a: 1, b: "hello" }, { a: 2, b: true }, 'b');  // string | boolean
 >b : string | boolean
 >func({ a: 1, b: "hello" }, { a: 2, b: true }, 'b') : string | boolean
->func : <T, U, K extends keyof (T | U)>(x: T, y: U, k: K) => (T | U)[K]
+>func : <T, U, K extends keyof T & keyof U>(x: T, y: U, k: K) => T | U[K]
 >{ a: 1, b: "hello" } : { a: number; b: string; }
 >a : number
 >1 : 1
@@= skipped -246, +246 lines =@@
 };
 
 function f90<T extends S2, K extends keyof S2>(x1: S2[keyof S2], x2: T[keyof S2], x3: S2[K]) {
->f90 : <T extends S2, K extends keyof S2>(x1: S2[keyof S2], x2: T[keyof S2], x3: S2[K]) => void
+>f90 : <T extends S2, K extends keyof S2>(x1: string, x2: T[keyof S2], x3: S2[K]) => void
 >x1 : string
 >x2 : T[keyof S2]
 >x3 : S2[K]
@@= skipped -193, +193 lines =@@
 // Modified repro from #12544
 
 function path<T, K1 extends keyof T>(obj: T, key1: K1): T[K1];
->path : { <T, K1 extends keyof T>(obj: T, key1: K1): T[K1]; <T_1, K1_1 extends keyof T_1, K2 extends keyof T_1[K1_1]>(obj: T_1, key1: K1_1, key2: K2): T_1[K1_1][K2]; <T_1, K1_1 extends keyof T_1, K2 extends keyof T_1[K1_1], K3 extends keyof T_1[K1_1][K2]>(obj: T_1, key1: K1_1, key2: K2, key3: K3): T_1[K1_1][K2][K3]; (obj: any, ...keys: (string | number)[]): any; }
+>path : { <T, K1 extends keyof T>(obj: T, key1: K1): T[K1]; <T, K1 extends keyof T, K2 extends keyof T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: any, ...keys: (string | number)[]): any; }
 >obj : T
 >key1 : K1
 
 function path<T, K1 extends keyof T, K2 extends keyof T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2];
->path : { <T_1, K1_1 extends keyof T_1>(obj: T_1, key1: K1_1): T_1[K1_1]; <T, K1 extends keyof T, K2 extends keyof T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T_1, K1_1 extends keyof T_1, K2_1 extends keyof T_1[K1_1], K3 extends keyof T_1[K1_1][K2_1]>(obj: T_1, key1: K1_1, key2: K2_1, key3: K3): T_1[K1_1][K2_1][K3]; (obj: any, ...keys: (string | number)[]): any; }
+>path : { <T, K1 extends keyof T>(obj: T, key1: K1): T[K1]; <T, K1 extends keyof T, K2 extends keyof T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: any, ...keys: (string | number)[]): any; }
 >obj : T
 >key1 : K1
 >key2 : K2
 
 function path<T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3];
->path : { <T_1, K1_1 extends keyof T_1>(obj: T_1, key1: K1_1): T_1[K1_1]; <T_1, K1_1 extends keyof T_1, K2_1 extends keyof T_1[K1_1]>(obj: T_1, key1: K1_1, key2: K2_1): T_1[K1_1][K2_1]; <T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: any, ...keys: (string | number)[]): any; }
+>path : { <T, K1 extends keyof T>(obj: T, key1: K1): T[K1]; <T, K1 extends keyof T, K2 extends keyof T[K1]>(obj: T, key1: K1, key2: K2): T[K1][K2]; <T, K1 extends keyof T, K2 extends keyof T[K1], K3 extends keyof T[K1][K2]>(obj: T, key1: K1, key2: K2, key3: K3): T[K1][K2][K3]; (obj: any, ...keys: (string | number)[]): any; }
 >obj : T
 >key1 : K1
 >key2 : K2
@@= skipped -172, +172 lines =@@
 >options : Options1<Data, Computed>
 
     get<K extends keyof (Data & Computed)>(key: K): (Data & Computed)[K];
->get : <K extends keyof (Data & Computed)>(key: K) => (Data & Computed)[K]
+>get : <K extends keyof Computed | keyof Data>(key: K) => Data & Computed[K]
 >key : K
 }
 
@@= skipped -44, +44 lines =@@
 >options : Options2<Data, Computed>
 
     get<K extends keyof Data | keyof Computed>(key: K): (Data & Computed)[K];
->get : <K extends keyof Data | keyof Computed>(key: K) => (Data & Computed)[K]
+>get : <K extends keyof Computed | keyof Data>(key: K) => Data & Computed[K]
 >key : K
 }
 
@@= skipped -12, +12 lines =@@
 }
 
 function f<K extends keyof R>(p: K) {
->f : <K extends keyof R>(p: K) => void
+>f : <K extends "p">(p: K) => void
 >p : K
 
     let a: any;
@@= skipped -96, +96 lines =@@
 
     handler.onChange('preset')
 >handler.onChange('preset') : void
->handler.onChange : (name: keyof T | "preset") => void
+>handler.onChange : (name: "preset" | keyof T) => void
 >handler : Handler<T & { preset: number; }>
->onChange : (name: keyof T | "preset") => void
+>onChange : (name: "preset" | keyof T) => void
 >'preset' : "preset"
 }
 
@@= skipped -80, +80 lines =@@
 // Repro from #13514
 
 declare function head<T extends Array<any>>(list: T): T[0];
->head : <T extends Array<any>>(list: T) => T[0]
+>head : <T extends any[]>(list: T) => T[0]
 >list : T
 
 // Repro from #13604
@@= skipped -35, +35 lines =@@
 >Form : Form<T>
 
     private childFormFactories: {[K in keyof T]: (v: T[K]) => Form<T[K]>}
->childFormFactories : { [K in keyof T]: (v: T[K]) => Form<T[K]>; }
+>childFormFactories : { [K in keyof T]: (v: T[K]) => Form<T[K]> }
 >v : T[K]
 
     public set<K extends keyof T>(prop: K, value: T[K]) {
@@= skipped -10, +10 lines =@@
 
         this.childFormFactories[prop](value)
 >this.childFormFactories[prop](value) : Form<T[K]>
->this.childFormFactories[prop] : { [K_1 in keyof T]: (v: T[K_1]) => Form<T[K_1]>; }[K]
->this.childFormFactories : { [K_1 in keyof T]: (v: T[K_1]) => Form<T[K_1]>; }
+>this.childFormFactories[prop] : { [K in keyof T]: (v: T[K]) => Form<T[K]> }[K]
+>this.childFormFactories : { [K in keyof T]: (v: T[K]) => Form<T[K]> }
 >this : this
->childFormFactories : { [K_1 in keyof T]: (v: T[K_1]) => Form<T[K_1]>; }
+>childFormFactories : { [K in keyof T]: (v: T[K]) => Form<T[K]> }
 >prop : K
 >value : T[K]
     }
@@= skipped -26, +26 lines =@@
 >this : this
 >props : Readonly<P>
 >Object.freeze(props) : Readonly<P>
->Object.freeze : { <T extends Function>(f: T): T; <T extends { [idx: string]: U | null | undefined | object; }, U extends string | bigint | number | boolean | symbol>(o: T): Readonly<T>; <T>(o: T): Readonly<T>; }
+>Object.freeze : { <T extends Function>(f: T): T; <T extends { [idx: string]: U | object | null | undefined; }, U extends string | number | bigint | symbol | boolean>(o: T): Readonly<T>; <T>(o: T): Readonly<T>; }
 >Object : ObjectConstructor
->freeze : { <T extends Function>(f: T): T; <T extends { [idx: string]: U | null | undefined | object; }, U extends string | bigint | number | boolean | symbol>(o: T): Readonly<T>; <T>(o: T): Readonly<T>; }
+>freeze : { <T extends Function>(f: T): T; <T extends { [idx: string]: U | object | null | undefined; }, U extends string | number | bigint | symbol | boolean>(o: T): Readonly<T>; <T>(o: T): Readonly<T>; }
 >props : P
     }
 }
@@= skipped -34, +34 lines =@@
 >super(merge(props, foo)) : void
 >super : typeof SampleClass
 >merge(props, foo) : T & Foo
->merge : <T_1, U>(obj1: T_1, obj2: U) => T_1 & U
+>merge : <T, U>(obj1: T, obj2: U) => T & U
 >props : T
 >foo : Foo
     }
@@= skipped -10, +10 lines =@@
 
         this.props.foo.concat;
 >this.props.foo.concat : (...strings: string[]) => string
->this.props.foo : (T & Foo)["foo"]
+>this.props.foo : T & Foo["foo"]
 >this.props : Readonly<T & Foo>
 >this : this
 >props : Readonly<T & Foo>
->foo : (T & Foo)["foo"]
+>foo : T & Foo["foo"]
 >concat : (...strings: string[]) => string
     }
 }
@@= skipped -143, +143 lines =@@
 
     take<{} | null | undefined>(o[k]);
 >take<{} | null | undefined>(o[k]) : void
->take : <T_1>(p: T_1) => void
+>take : <T>(p: T) => void
 >o[k] : T[K]
 >o : T
 >k : K
 
     take<any>(o[k]);
 >take<any>(o[k]) : void
->take : <T_1>(p: T_1) => void
+>take : <T>(p: T) => void
 >o[k] : T[K]
 >o : T
 >k : K
@@= skipped -38, +38 lines =@@
 >Foo7 : T
 
 declare function f7<K extends keyof I7>(type: K): Foo7<I7[K]>;
->f7 : <K extends keyof I7>(type: K) => Foo7<I7[K]>
+>f7 : <K extends "x">(type: K) => I7[K]
 >type : K
 
 // Repro from #21770
@@= skipped -46, +46 lines =@@
 // Repro from #26409
 
 const cf1 = <T extends { [P in K]: string; } & { cool: string; }, K extends keyof T>(t: T, k: K) =>
->cf1 : <T extends { [P in K]: string; } & { cool: string; }, K extends keyof T>(t: T, k: K) => void
-><T extends { [P in K]: string; } & { cool: string; }, K extends keyof T>(t: T, k: K) =>{    const s: string = t[k];    t.cool;} : <T extends { [P in K]: string; } & { cool: string; }, K extends keyof T>(t: T, k: K) => void
+>cf1 : <T extends { [P in K]: string } & { cool: string; }, K extends keyof T>(t: T, k: K) => void
+><T extends { [P in K]: string; } & { cool: string; }, K extends keyof T>(t: T, k: K) =>{    const s: string = t[k];    t.cool;} : <T extends { [P in K]: string } & { cool: string; }, K extends keyof T>(t: T, k: K) => void
 >cool : string
 >t : T
 >k : K
@@= skipped -20, +20 lines =@@
 };
 
 const cf2 = <T extends { [P in K | "cool"]: string; }, K extends keyof T>(t: T, k: K) =>
->cf2 : <T extends { [P in K | "cool"]: string; }, K extends keyof T>(t: T, k: K) => void
-><T extends { [P in K | "cool"]: string; }, K extends keyof T>(t: T, k: K) =>{    const s: string = t[k];    t.cool;} : <T extends { [P in K | "cool"]: string; }, K extends keyof T>(t: T, k: K) => void
+>cf2 : <T extends { [P in "cool" | K]: string }, K extends keyof T>(t: T, k: K) => void
+><T extends { [P in K | "cool"]: string; }, K extends keyof T>(t: T, k: K) =>{    const s: string = t[k];    t.cool;} : <T extends { [P in "cool" | K]: string }, K extends keyof T>(t: T, k: K) => void
 >t : T
 >k : K
 {

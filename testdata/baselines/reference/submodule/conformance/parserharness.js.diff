--- old.parserharness.js
+++ new.parserharness.js
@@= skipped -2082, +2082 lines =@@
 }
 
 
+//// [io.js]
+//// [typescript.js]
+//// [typescriptServices.js]
+//// [diff.js]
 //// [parserharness.js]
-//ï»¿
-// Copyright (c) Microsoft Corporation.  All rights reserved.
-// 
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//   http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//
-var __extends = (this && this.__extends) || (function () {
-    var extendStatics = function (d, b) {
-        extendStatics = Object.setPrototypeOf ||
-            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
-            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
-        return extendStatics(d, b);
-    };
-    return function (d, b) {
-        if (typeof b !== "function" && b !== null)
-            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
-        extendStatics(d, b);
-        function __() { this.constructor = d; }
-        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
-    };
-})();
-///<reference path='..\compiler\io.ts'/>
-///<reference path='..\compiler\typescript.ts'/>
-///<reference path='..\services\typescriptServices.ts' />
-///<reference path='diff.ts'/>
 function switchToForwardSlashes(path) {
     return path.replace(/\\/g, "/");
 }
@@= skipped -57, +28 lines =@@
 }
 var Harness;
 (function (Harness) {
-    // Settings 
     Harness.userSpecifiedroot = "";
     var global = Function("return this").call(null);
     Harness.usePull = false;
-    // Assert functions
-    var Assert;
+    let Assert;
     (function (Assert) {
         Assert.bugIds = [];
-        Assert.throwAssertError = function (error) {
+        Assert.throwAssertError = (error) => {
             throw error;
         };
-        // Marks that the current scenario is impacted by a bug
         function bug(id) {
             if (Assert.bugIds.indexOf(id) < 0) {
                 Assert.bugIds.push(id);
             }
         }
         Assert.bug = bug;
-        // If there are any bugs in the test code, mark the scenario as impacted appropriately
         function bugs(content) {
             var bugs = content.match(/\bbug (\d+)/i);
             if (bugs) {
-                bugs.forEach(function (bug) { return assert.bug(bug); });
+                bugs.forEach(bug => assert.bug(bug));
             }
         }
         Assert.bugs = bugs;
@@= skipped -35, +31 lines =@@
         function arrayLengthIs(arr, length) {
             if (arr.length != length) {
                 var actual = '';
-                arr.forEach(function (n) { return actual = actual + '\n      ' + n.toString(); });
+                arr.forEach(n => actual = actual + '\n      ' + n.toString());
                 Assert.throwAssertError(new Error('Expected array to have ' + length + ' elements. Actual elements were:' + actual));
             }
         }
@@= skipped -26, +26 lines =@@
         function compilerWarning(result, line, column, desc) {
             if (!result.isErrorAt(line, column, desc)) {
                 var actual = '';
-                result.errors.forEach(function (err) {
+                result.errors.forEach(err => {
                     actual = actual + '\n     ' + err.toString();
                 });
                 Assert.throwAssertError(new Error("Expected compiler warning at (" + line + ", " + column + "): " + desc + "\nActual errors follow: " + actual));
@@= skipped -54, +54 lines =@@
         }
         Assert.arrayContainsOnce = arrayContainsOnce;
     })(Assert = Harness.Assert || (Harness.Assert = {}));
-    /** Splits the given string on \r\n or on only \n if that fails */
     function splitContentByNewlines(content) {
-        // Split up the input file by line
-        // Note: IE JS engine incorrectly handles consecutive delimiters here when using RegExp split, so
-        // we have to string-based splitting instead and try to figure out the delimiting chars
         var lines = content.split('\r\n');
         if (lines.length === 1) {
             lines = content.split('\n');
@@= skipped -12, +8 lines =@@
         return lines;
     }
     Harness.splitContentByNewlines = splitContentByNewlines;
-    /** Reads a file under /tests */
     function readFile(path) {
         if (path.indexOf('tests') < 0) {
             path = "tests/" + path;
@@= skipped -12, +11 lines =@@
         return content;
     }
     Harness.readFile = readFile;
-    var Logger = /** @class */ (function () {
-        function Logger() {
-        }
-        Logger.prototype.start = function (fileName, priority) { };
-        Logger.prototype.end = function (fileName) { };
-        Logger.prototype.scenarioStart = function (scenario) { };
-        Logger.prototype.scenarioEnd = function (scenario, error) { };
-        Logger.prototype.testStart = function (test) { };
-        Logger.prototype.pass = function (test) { };
-        Logger.prototype.bug = function (test) { };
-        Logger.prototype.fail = function (test) { };
-        Logger.prototype.error = function (test, error) { };
-        Logger.prototype.comment = function (comment) { };
-        Logger.prototype.verify = function (test, passed, actual, expected, message) { };
-        return Logger;
-    }());
+    class Logger {
+        start(fileName, priority) { }
+        end(fileName) { }
+        scenarioStart(scenario) { }
+        scenarioEnd(scenario, error) { }
+        testStart(test) { }
+        pass(test) { }
+        bug(test) { }
+        fail(test) { }
+        error(test, error) { }
+        comment(comment) { }
+        verify(test, passed, actual, expected, message) { }
+    }
     Harness.Logger = Logger;
-    // Logger-related functions
     var loggers = [];
     function registerLogger(logger) {
         loggers.push(logger);
     }
     Harness.registerLogger = registerLogger;
-    function emitLog(field) {
-        var params = [];
-        for (var _i = 1; _i < arguments.length; _i++) {
-            params[_i - 1] = arguments[_i];
-        }
+    function emitLog(field, ...params) {
         for (var i = 0; i < loggers.length; i++) {
             if (typeof loggers[i][field] === 'function') {
                 loggers[i][field].apply(loggers[i], params);
@@= skipped -35, +27 lines =@@
         }
     }
     Harness.emitLog = emitLog;
-    var Runnable = /** @class */ (function () {
-        function Runnable(description, block) {
+    class Runnable {
+        description;
+        block;
+        constructor(description, block) {
             this.description = description;
             this.block = block;
-            // The error, if any, that occurred when running 'block'
-            this.error = null;
-            // Whether or not this object has any failures (including in its descendants)
-            this.passed = null;
-            // A list of bugs impacting this object
-            this.bugs = [];
-            // A list of all our child Runnables
-            this.children = [];
         }
-        Runnable.prototype.addChild = function (child) {
+        static currentStack = [];
+        error = null;
+        passed = null;
+        bugs = [];
+        children = [];
+        addChild(child) {
             this.children.push(child);
-        };
-        /** Call function fn, which may take a done function and may possibly execute
-         *  asynchronously, calling done when finished. Returns true or false depending
-         *  on whether the function was asynchronous or not.
-         */
-        Runnable.prototype.call = function (fn, done) {
+        }
+        call(fn, done) {
             var isAsync = true;
             try {
                 if (fn.length === 0) {
-                    // No async.
                     fn();
                     done();
                     return false;
                 }
                 else {
-                    // Possibly async
                     Runnable.pushGlobalErrorHandler(done);
                     fn(function () {
-                        isAsync = false; // If we execute synchronously, this will get called before the return below.
+                        isAsync = false;
                         Runnable.popGlobalErrorHandler();
                         done();
                     });
@@= skipped -44, +37 lines =@@
                 done(e);
                 return false;
             }
-        };
-        Runnable.prototype.run = function (done) { };
-        Runnable.prototype.runBlock = function (done) {
+        }
+        run(done) { }
+        runBlock(done) {
             return this.call(this.block, done);
-        };
-        Runnable.prototype.runChild = function (index, done) {
-            var _this = this;
-            return this.call((function (done) { return _this.children[index].run(done); }), done);
-        };
-        Runnable.pushGlobalErrorHandler = function (done) {
+        }
+        runChild(index, done) {
+            return this.call(((done) => this.children[index].run(done)), done);
+        }
+        static errorHandlerStack = [];
+        static pushGlobalErrorHandler(done) {
             errorHandlerStack.push(function (e) {
                 done(e);
             });
-        };
-        Runnable.popGlobalErrorHandler = function () {
+        }
+        static popGlobalErrorHandler() {
             errorHandlerStack.pop();
-        };
-        Runnable.handleError = function (e) {
+        }
+        static handleError(e) {
             if (errorHandlerStack.length === 0) {
                 IO.printLine('Global error: ' + e);
             }
             else {
                 errorHandlerStack[errorHandlerStack.length - 1](e);
             }
-        };
-        // The current stack of Runnable objects
-        Runnable.currentStack = [];
-        Runnable.errorHandlerStack = [];
-        return Runnable;
-    }());
+        }
+    }
     Harness.Runnable = Runnable;
-    var TestCase = /** @class */ (function (_super) {
-        __extends(TestCase, _super);
-        function TestCase(description, block) {
-            var _this = _super.call(this, description, block) || this;
-            _this.description = description;
-            _this.block = block;
-            return _this;
+    class TestCase extends Runnable {
+        description;
+        block;
+        constructor(description, block) {
+            super(description, block);
+            this.description = description;
+            this.block = block;
         }
-        TestCase.prototype.addChild = function (child) {
+        addChild(child) {
             throw new Error("Testcases may not be nested inside other testcases");
-        };
-        /** Run the test case block and fail the test if it raised an error. If no error is raised, the test passes. */
-        TestCase.prototype.run = function (done) {
+        }
+        run(done) {
             var that = this;
             Runnable.currentStack.push(this);
             emitLog('testStart', { desc: this.description });
@@= skipped -62, +57 lines =@@
                     done();
                 });
             }
-        };
-        return TestCase;
-    }(Runnable));
+        }
+    }
     Harness.TestCase = TestCase;
-    var Scenario = /** @class */ (function (_super) {
-        __extends(Scenario, _super);
-        function Scenario(description, block) {
-            var _this = _super.call(this, description, block) || this;
-            _this.description = description;
-            _this.block = block;
-            return _this;
+    class Scenario extends Runnable {
+        description;
+        block;
+        constructor(description, block) {
+            super(description, block);
+            this.description = description;
+            this.block = block;
         }
-        /** Run the block, and if the block doesn't raise an error, run the children. */
-        Scenario.prototype.run = function (done) {
+        run(done) {
             var that = this;
             Runnable.currentStack.push(this);
             emitLog('scenarioStart', { desc: this.description });
@@= skipped -23, +21 lines =@@
                     that.passed = false;
                     that.error = e;
                     var metadata = { id: undefined, desc: this.description, pass: false, bugs: assert.bugIds };
-                    // Report all bugs affecting this scenario
-                    assert.bugIds.forEach(function (desc) { return emitLog('bug', metadata, desc); });
+                    assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));
                     emitLog('scenarioEnd', metadata, e);
                     done();
                 }
                 else {
-                    that.passed = true; // so far so good.
+                    that.passed = true;
                     that.runChildren(done);
                 }
             });
-        };
-        /** Run the children of the scenario (other scenarios and test cases). If any fail,
-         *  set this scenario to failed. Synchronous tests will run synchronously without
-         *  adding stack frames.
-         */
-        Scenario.prototype.runChildren = function (done, index) {
-            if (index === void 0) { index = 0; }
+        }
+        runChildren(done, index = 0) {
             var that = this;
             var async = false;
             for (; index < this.children.length; index++) {
@@= skipped -29, +23 lines =@@
                     return;
             }
             var metadata = { id: undefined, desc: this.description, pass: this.passed, bugs: assert.bugIds };
-            // Report all bugs affecting this scenario
-            assert.bugIds.forEach(function (desc) { return emitLog('bug', metadata, desc); });
+            assert.bugIds.forEach(desc => emitLog('bug', metadata, desc));
             emitLog('scenarioEnd', metadata);
             done();
-        };
-        return Scenario;
-    }(Runnable));
+        }
+    }
     Harness.Scenario = Scenario;
-    var Run = /** @class */ (function (_super) {
-        __extends(Run, _super);
-        function Run() {
-            return _super.call(this, 'Test Run', null) || this;
+    class Run extends Runnable {
+        constructor() {
+            super('Test Run', null);
         }
-        Run.prototype.run = function () {
+        run() {
             emitLog('start');
             this.runChildren();
-        };
-        Run.prototype.runChildren = function (index) {
-            if (index === void 0) { index = 0; }
+        }
+        runChildren(index = 0) {
             var async = false;
             var that = this;
             for (; index < this.children.length; index++) {
-                // Clear out bug descriptions
                 assert.bugIds = [];
                 async = this.runChild(index, function (e) {
                     if (async) {
@@= skipped -35, +30 lines =@@
             }
             Perf.runBenchmarks();
             emitLog('end');
-        };
-        return Run;
-    }(Runnable));
+        }
+    }
     Harness.Run = Run;
-    // Performance test
-    var Perf;
+    let Perf;
     (function (Perf) {
-        var Clock;
+        let Clock;
         (function (Clock) {
             if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
-                // Running in JSHost.
                 global['WScript'].InitializeProjection();
                 Clock.now = function () {
                     return TestUtilities.QueryPerformanceCounter();
@@= skipped -24, +21 lines =@@
                 Clock.resolution = 1000;
             }
         })(Clock = Perf.Clock || (Perf.Clock = {}));
-        var Timer = /** @class */ (function () {
-            function Timer() {
+        class Timer {
+            startTime;
+            time = 0;
+            start() {
                 this.time = 0;
-            }
-            Timer.prototype.start = function () {
-                this.time = 0;
                 this.startTime = Clock.now();
-            };
-            Timer.prototype.end = function () {
-                // Set time to MS.
+            }
+            end() {
                 this.time = (Clock.now() - this.startTime) / Clock.resolution * 1000;
-            };
-            return Timer;
-        }());
-        Perf.Timer = Timer;
-        var Dataset = /** @class */ (function () {
-            function Dataset() {
-                this.data = [];
             }
-            Dataset.prototype.add = function (value) {
+        }
+        Perf.Timer = Timer;
+        class Dataset {
+            data = [];
+            add(value) {
                 this.data.push(value);
-            };
-            Dataset.prototype.mean = function () {
+            }
+            mean() {
                 var sum = 0;
                 for (var i = 0; i < this.data.length; i++) {
                     sum += this.data[i];
                 }
                 return sum / this.data.length;
-            };
-            Dataset.prototype.min = function () {
+            }
+            min() {
                 var min = this.data[0];
                 for (var i = 1; i < this.data.length; i++) {
                     if (this.data[i] < min) {
@@= skipped -37, +32 lines =@@
                     }
                 }
                 return min;
-            };
-            Dataset.prototype.max = function () {
+            }
+            max() {
                 var max = this.data[0];
                 for (var i = 1; i < this.data.length; i++) {
                     if (this.data[i] > max) {
@@= skipped -9, +9 lines =@@
                     }
                 }
                 return max;
-            };
-            Dataset.prototype.stdDev = function () {
+            }
+            stdDev() {
                 var sampleMean = this.mean();
                 var sumOfSquares = 0;
                 for (var i = 0; i < this.data.length; i++) {
                     sumOfSquares += Math.pow(this.data[i] - sampleMean, 2);
                 }
                 return Math.sqrt(sumOfSquares / this.data.length);
-            };
-            return Dataset;
-        }());
-        Perf.Dataset = Dataset;
-        // Base benchmark class with some defaults.
-        var Benchmark = /** @class */ (function () {
-            function Benchmark() {
-                this.iterations = 10;
-                this.description = "";
-                this.results = {};
             }
-            Benchmark.prototype.bench = function (subBench) { };
-            Benchmark.prototype.before = function () { };
-            Benchmark.prototype.beforeEach = function () { };
-            Benchmark.prototype.after = function () { };
-            Benchmark.prototype.afterEach = function () { };
-            Benchmark.prototype.addTimingFor = function (name, timing) {
+        }
+        Perf.Dataset = Dataset;
+        class Benchmark {
+            iterations = 10;
+            description = "";
+            bench(subBench) { }
+            before() { }
+            beforeEach() { }
+            after() { }
+            afterEach() { }
+            results = {};
+            addTimingFor(name, timing) {
                 this.results[name] = this.results[name] || new Dataset();
                 this.results[name].add(timing);
-            };
-            return Benchmark;
-        }());
+            }
+        }
         Perf.Benchmark = Benchmark;
         Perf.benchmarks = [];
         var timeFunction;
-        timeFunction = function (benchmark, description, name, f) {
-            if (description === void 0) { description = benchmark.description; }
-            if (name === void 0) { name = ''; }
-            if (f === void 0) { f = benchmark.bench; }
+        timeFunction = function (benchmark, description = benchmark.description, name = '', f = benchmark.bench) {
             var t = new Timer();
             t.start();
             var subBenchmark = function (name, f) {
@@= skipped -73, +65 lines =@@
             }
         }
         Perf.runBenchmarks = runBenchmarks;
-        // Replace with better type when classes are assignment compatible with
-        // the below type.
-        // export function addBenchmark(BenchmarkClass: {new(): Benchmark;}) {
         function addBenchmark(BenchmarkClass) {
             Perf.benchmarks.push(BenchmarkClass);
         }
         Perf.addBenchmark = addBenchmark;
     })(Perf = Harness.Perf || (Harness.Perf = {}));
-    /** Functionality for compiling TypeScript code */
-    var Compiler;
+    let Compiler;
     (function (Compiler) {
-        /** Aggregate various writes into a single array of lines. Useful for passing to the
-         *  TypeScript compiler to fill with source code or errors.
-         */
-        var WriterAggregator = /** @class */ (function () {
-            function WriterAggregator() {
-                this.lines = [];
-                this.currentLine = "";
-            }
-            WriterAggregator.prototype.Write = function (str) {
+        class WriterAggregator {
+            lines = [];
+            currentLine = "";
+            Write(str) {
                 this.currentLine += str;
-            };
-            WriterAggregator.prototype.WriteLine = function (str) {
+            }
+            WriteLine(str) {
                 this.lines.push(this.currentLine + str);
                 this.currentLine = "";
-            };
-            WriterAggregator.prototype.Close = function () {
+            }
+            Close() {
                 if (this.currentLine.length > 0) {
                     this.lines.push(this.currentLine);
                 }
                 this.currentLine = "";
-            };
-            WriterAggregator.prototype.reset = function () {
+            }
+            reset() {
                 this.lines = [];
                 this.currentLine = "";
-            };
-            return WriterAggregator;
-        }());
-        Compiler.WriterAggregator = WriterAggregator;
-        /** Mimics having multiple files, later concatenated to a single file. */
-        var EmitterIOHost = /** @class */ (function () {
-            function EmitterIOHost() {
-                this.fileCollection = {};
             }
-            /** create file gets the whole path to create, so this works as expected with the --out parameter */
-            EmitterIOHost.prototype.createFile = function (s, useUTF8) {
+        }
+        Compiler.WriterAggregator = WriterAggregator;
+        class EmitterIOHost {
+            fileCollection = {};
+            createFile(s, useUTF8) {
                 if (this.fileCollection[s]) {
                     return this.fileCollection[s];
                 }
                 var writer = new Harness.Compiler.WriterAggregator();
                 this.fileCollection[s] = writer;
                 return writer;
-            };
-            EmitterIOHost.prototype.directoryExists = function (s) { return false; };
-            EmitterIOHost.prototype.fileExists = function (s) { return typeof this.fileCollection[s] !== 'undefined'; };
-            EmitterIOHost.prototype.resolvePath = function (s) { return s; };
-            EmitterIOHost.prototype.reset = function () { this.fileCollection = {}; };
-            EmitterIOHost.prototype.toArray = function () {
+            }
+            directoryExists(s) { return false; }
+            fileExists(s) { return typeof this.fileCollection[s] !== 'undefined'; }
+            resolvePath(s) { return s; }
+            reset() { this.fileCollection = {}; }
+            toArray() {
                 var result = [];
                 for (var p in this.fileCollection) {
                     if (this.fileCollection.hasOwnProperty(p)) {
@@= skipped -71, +57 lines =@@
                     }
                 }
                 return result;
-            };
-            return EmitterIOHost;
-        }());
+            }
+        }
         Compiler.EmitterIOHost = EmitterIOHost;
         var libFolder = global['WScript'] ? TypeScript.filePath(global['WScript'].ScriptFullName) : (__dirname + '/');
         Compiler.libText = IO ? IO.readFile(libFolder + "lib.d.ts") : '';
@@= skipped -30, +29 lines =@@
         Compiler.makeDefaultCompilerForTest = makeDefaultCompilerForTest;
         var compiler;
         recreate();
-        // pullUpdateUnit is sufficient if an existing unit is updated, if a new unit is added we need to do a full typecheck
         var needsFullTypeCheck = true;
         function compile(code, filename) {
             if (Harness.usePull) {
@@= skipped -9, +8 lines =@@
                     needsFullTypeCheck = false;
                 }
                 else {
-                    // requires unit to already exist in the compiler
                     compiler.pullUpdateUnit(new TypeScript.StringSourceText(""), filename, true);
                     compiler.pullUpdateUnit(new TypeScript.StringSourceText(code), filename, true);
                 }
@@= skipped -10, +9 lines =@@
             }
         }
         Compiler.compile = compile;
-        // Types
-        var Type = /** @class */ (function () {
-            function Type(type, code, identifier) {
+        class Type {
+            type;
+            code;
+            identifier;
+            constructor(type, code, identifier) {
                 this.type = type;
                 this.code = code;
                 this.identifier = identifier;
             }
-            Type.prototype.normalizeToArray = function (arg) {
+            normalizeToArray(arg) {
                 if ((Array.isArray && Array.isArray(arg)) || arg instanceof Array)
                     return arg;
                 return [arg];
-            };
-            Type.prototype.compilesOk = function (testCode) {
+            }
+            compilesOk(testCode) {
                 var errors = null;
                 compileString(testCode, 'test.ts', function (compilerResult) {
                     errors = compilerResult.errors;
                 });
                 return errors.length === 0;
-            };
-            Type.prototype.isSubtypeOf = function (other) {
+            }
+            isSubtypeOf(other) {
                 var testCode = 'class __test1__ {\n';
                 testCode += '    public test() {\n';
                 testCode += '        ' + other.code + ';\n';
@@= skipped -33, +35 lines =@@
                 testCode += '    }\n';
                 testCode += '}\n';
                 return this.compilesOk(testCode);
-            };
-            // TODO: Find an implementation of isIdenticalTo that works.
-            //public isIdenticalTo(other: Type) {
-            //    var testCode = 'module __test1__ {\n';
-            //    testCode += '    ' + this.code + ';\n';
-            //    testCode += '    export var __val__ = ' + this.identifier + ';\n';
-            //    testCode += '}\n';
-            //    testCode += 'var __test1__val__ = __test1__.__val__;\n';
-            //    testCode += 'module __test2__ {\n';
-            //    testCode += '    ' + other.code + ';\n';
-            //    testCode += '    export var __val__ = ' + other.identifier + ';\n';
-            //    testCode += '}\n';
-            //    testCode += 'var __test2__val__ = __test2__.__val__;\n';
-            //    testCode += 'function __test__function__() { if(true) { return __test1__val__ }; return __test2__val__; }';
-            //    return this.compilesOk(testCode);
-            //}
-            Type.prototype.assertSubtypeOf = function (others) {
+            }
+            assertSubtypeOf(others) {
                 others = this.normalizeToArray(others);
                 for (var i = 0; i < others.length; i++) {
                     if (!this.isSubtypeOf(others[i])) {
                         throw new Error("Expected " + this.type + " to be a subtype of " + others[i].type);
                     }
                 }
-            };
-            Type.prototype.assertNotSubtypeOf = function (others) {
+            }
+            assertNotSubtypeOf(others) {
                 others = this.normalizeToArray(others);
                 for (var i = 0; i < others.length; i++) {
                     if (this.isSubtypeOf(others[i])) {
                         throw new Error("Expected " + this.type + " to be a subtype of " + others[i].type);
                     }
                 }
-            };
-            //public assertIdenticalTo(other: Type) {
-            //    if (!this.isIdenticalTo(other)) {
-            //        throw new Error("Expected " + this.type + " to be identical to " + other.type);
-            //    }
-            //}
-            //public assertNotIdenticalTo(other: Type) {
-            //    if (!this.isIdenticalTo(other)) {
-            //        throw new Error("Expected " + this.type + " to not be identical to " + other.type);
-            //    }
-            //}
-            Type.prototype.isAssignmentCompatibleWith = function (other) {
+            }
+            isAssignmentCompatibleWith(other) {
                 var testCode = 'module __test1__ {\n';
                 testCode += '    ' + this.code + ';\n';
                 testCode += '    export var __val__ = ' + this.identifier + ';\n';
@@= skipped -55, +30 lines =@@
                 testCode += 'var __test2__val__ = __test2__.__val__;\n';
                 testCode += '__test2__val__ = __test1__val__;';
                 return this.compilesOk(testCode);
-            };
-            Type.prototype.assertAssignmentCompatibleWith = function (others) {
+            }
+            assertAssignmentCompatibleWith(others) {
                 others = this.normalizeToArray(others);
                 for (var i = 0; i < others.length; i++) {
                     var other = others[i];
@@= skipped -9, +9 lines =@@
                         throw new Error("Expected " + this.type + " to be assignment compatible with " + other.type);
                     }
                 }
-            };
-            Type.prototype.assertNotAssignmentCompatibleWith = function (others) {
+            }
+            assertNotAssignmentCompatibleWith(others) {
                 others = this.normalizeToArray(others);
                 for (var i = 0; i < others.length; i++) {
                     var other = others[i];
@@= skipped -9, +9 lines =@@
                         throw new Error("Expected " + this.type + " to not be assignment compatible with " + other.type);
                     }
                 }
-            };
-            Type.prototype.assertThisCanBeAssignedTo = function (desc, these, notThese) {
-                var _this = this;
-                it(desc + " is assignable to ", function () {
-                    _this.assertAssignmentCompatibleWith(these);
+            }
+            assertThisCanBeAssignedTo(desc, these, notThese) {
+                it(desc + " is assignable to ", () => {
+                    this.assertAssignmentCompatibleWith(these);
                 });
-                it(desc + " not assignable to ", function () {
-                    _this.assertNotAssignmentCompatibleWith(notThese);
+                it(desc + " not assignable to ", () => {
+                    this.assertNotAssignmentCompatibleWith(notThese);
                 });
-            };
-            return Type;
-        }());
+            }
+        }
         Compiler.Type = Type;
-        var TypeFactory = /** @class */ (function () {
-            function TypeFactory() {
+        class TypeFactory {
+            any;
+            number;
+            string;
+            boolean;
+            constructor() {
                 this.any = this.get('var x : any', 'x');
                 this.number = this.get('var x : number', 'x');
                 this.string = this.get('var x : string', 'x');
                 this.boolean = this.get('var x : boolean', 'x');
             }
-            TypeFactory.prototype.get = function (code, target) {
+            get(code, target) {
                 var targetIdentifier = '';
                 var targetPosition = -1;
                 if (typeof target === "string") {
@@= skipped -40, +42 lines =@@
                     throw new Error("Type definition contains errors: " + errors.join(","));
                 var matchingIdentifiers = [];
                 if (!Harness.usePull) {
-                    // This will find the requested identifier in the first script where it's present, a naive search of each member in each script,
-                    // which means this won't play nicely if the same identifier is used in multiple units, but it will enable this to work on multi-file tests.
-                    // m = 1 because the first script will always be lib.d.ts which we don't want to search.                                
                     for (var m = 1; m < compiler.scripts.members.length; m++) {
                         var script = compiler.scripts.members[m];
                         var enclosingScopeContext = TypeScript.findEnclosingScopeAt(new TypeScript.NullLogger(), script, new TypeScript.StringSourceText(code), 0, false);
@@= skipped -22, +19 lines =@@
                                 var tyInfo = compiler.pullGetTypeInfoAtPosition(targetPosition, script2);
                                 var name = this.getTypeInfoName(tyInfo.ast);
                                 var foundValue = new Type(tyInfo.typeInfo, code, name);
-                                if (!matchingIdentifiers.some(function (value) { return (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type); })) {
+                                if (!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type))) {
                                     matchingIdentifiers.push(foundValue);
                                 }
                             }
@@= skipped -10, +10 lines =@@
                                     var name = this.getTypeInfoName(tyInfo.ast);
                                     if (name === targetIdentifier) {
                                         var foundValue = new Type(tyInfo.typeInfo, code, targetIdentifier);
-                                        if (!matchingIdentifiers.some(function (value) { return (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type); })) {
+                                        if (!matchingIdentifiers.some(value => (value.identifier === foundValue.identifier) && (value.code === foundValue.code) && (value.type === foundValue.type))) {
                                             matchingIdentifiers.push(foundValue);
                                         }
                                     }
@@= skipped -23, +23 lines =@@
                 else {
                     return matchingIdentifiers[0];
                 }
-            };
-            TypeFactory.prototype.getTypeInfoName = function (ast) {
+            }
+            getTypeInfoName(ast) {
                 var name = '';
                 switch (ast.nodeType) {
-                    case TypeScript.NodeType.Name: // Type Name?
+                    case TypeScript.NodeType.Name:
                     case TypeScript.NodeType.Null:
                     case TypeScript.NodeType.List:
                     case TypeScript.NodeType.Empty:
@@= skipped -28, +28 lines =@@
                         name = ast.text;
                         break;
                     case TypeScript.NodeType.Return:
-                        //name = (<TypeScript.ReturnStatement>tyInfo.ast).returnExpression.actualText; // why is this complaining?
                         break;
                     case TypeScript.NodeType.InterfaceDeclaration:
                         name = ast.name.actualText;
@@= skipped -12, +11 lines =@@
                         name = ast.name.actualText;
                         break;
                     case TypeScript.NodeType.FuncDecl:
-                        name = !ast.name ? "" : ast.name.actualText; // name == null for lambdas
+                        name = !ast.name ? "" : ast.name.actualText;
                         break;
                     default:
-                        // TODO: is there a reason to mess with all the special cases above and not just do this (ie take whatever property is there and works?)
                         var a = ast;
                         name = (a.id) ? (a.id.actualText) : (a.name) ? a.name.actualText : (a.text) ? a.text : '';
                         break;
                 }
                 return name;
-            };
-            TypeFactory.prototype.isOfType = function (expr, expectedType) {
+            }
+            isOfType(expr, expectedType) {
                 var actualType = this.get('var _v_a_r_ = ' + expr, '_v_a_r_');
                 it('Expression "' + expr + '" is of type "' + expectedType + '"', function () {
                     assert.equal(actualType.type, expectedType);
                 });
-            };
-            return TypeFactory;
-        }());
+            }
+        }
         Compiler.TypeFactory = TypeFactory;
-        /** Generates a .d.ts file for the given code
-          * @param verifyNoDeclFile pass true when the given code should generate no decl file, false otherwise
-          * @param unitName add the given code under thie name, else use '0.ts'
-          * @param compilationContext a set of functions to be run before and after compiling this code for doing things like adding dependencies first
-          * @param references the set of referenced files used by the given code
-          */
         function generateDeclFile(code, verifyNoDeclFile, unitName, compilationContext, references) {
             reset();
             compiler.settings.generateDeclarationFiles = true;
@@= skipped -39, +31 lines =@@
                 var outputs = {};
                 compiler.settings.outputOption = "";
                 compiler.parseEmitOption({
-                    createFile: function (fn) {
+                    createFile: (fn) => {
                         outputs[fn] = new Harness.Compiler.WriterAggregator();
                         return outputs[fn];
                     },
-                    directoryExists: function (path) { return true; },
-                    fileExists: function (path) { return true; },
-                    resolvePath: function (path) { return path; }
+                    directoryExists: (path) => true,
+                    fileExists: (path) => true,
+                    resolvePath: (path) => path
                 });
                 compiler.emitDeclarations();
                 var results = null;
@@= skipped -40, +40 lines =@@
             return '';
         }
         Compiler.generateDeclFile = generateDeclFile;
-        /** Contains the code and errors of a compilation and some helper methods to check its status. */
-        var CompilerResult = /** @class */ (function () {
-            /** @param fileResults an array of strings for the filename and an ITextWriter with its code */
-            function CompilerResult(fileResults, errorLines, scripts) {
+        class CompilerResult {
+            fileResults;
+            scripts;
+            code;
+            errors;
+            constructor(fileResults, errorLines, scripts) {
                 this.fileResults = fileResults;
                 this.scripts = scripts;
                 var lines = [];
-                fileResults.forEach(function (v) { return lines = lines.concat(v.file.lines); });
+                fileResults.forEach(v => lines = lines.concat(v.file.lines));
                 this.code = lines.join("\n");
                 this.errors = [];
                 for (var i = 0; i < errorLines.length; i++) {
                     if (Harness.usePull) {
-                        var err = errorLines[i]; // TypeScript.PullError
+                        var err = errorLines[i];
                         this.errors.push(new CompilerError(err.filename, 0, 0, err.message));
                     }
                     else {
@@= skipped -26, +28 lines =@@
                     }
                 }
             }
-            CompilerResult.prototype.isErrorAt = function (line, column, message) {
+            isErrorAt(line, column, message) {
                 for (var i = 0; i < this.errors.length; i++) {
                     if (this.errors[i].line === line && this.errors[i].column === column && this.errors[i].message === message)
                         return true;
                 }
                 return false;
-            };
-            return CompilerResult;
-        }());
+            }
+        }
         Compiler.CompilerResult = CompilerResult;
-        // Compiler Error.
-        var CompilerError = /** @class */ (function () {
-            function CompilerError(file, line, column, message) {
+        class CompilerError {
+            file;
+            line;
+            column;
+            message;
+            constructor(file, line, column, message) {
                 this.file = file;
                 this.line = line;
                 this.column = column;
                 this.message = message;
             }
-            CompilerError.prototype.toString = function () {
+            toString() {
                 return this.file + "(" + this.line + "," + this.column + "): " + this.message;
-            };
-            return CompilerError;
-        }());
+            }
+        }
         Compiler.CompilerError = CompilerError;
-        /** Create a new instance of the compiler with default settings and lib.d.ts, then typecheck */
         function recreate() {
             compiler = makeDefaultCompilerForTest();
             if (Harness.usePull) {
@@= skipped -38, +38 lines =@@
         function reset() {
             stdout.reset();
             stderr.reset();
-            var files = compiler.units.map(function (value) { return value.filename; });
+            var files = compiler.units.map((value) => value.filename);
             for (var i = 0; i < files.length; i++) {
                 var fname = files[i];
                 if (fname !== 'lib.d.ts') {
@@= skipped -20, +20 lines =@@
                 }
             }
             if (!script) {
-                // TODO: make this toggleable, shouldn't be necessary once typecheck bugs are cleaned up
-                // but without it subsequent tests are treated as edits, making for somewhat useful stress testing
-                // of persistent typecheck state
-                //compiler.addUnit("", uName, isResident, references); // equivalent to compiler.deleteUnit(...)
                 script = compiler.addUnit(code, uName, isResident, references);
                 needsFullTypeCheck = true;
             }
@@= skipped -27, +23 lines =@@
         }
         Compiler.compileFile = compileFile;
         function compileUnit(code, filename, callback, settingsCallback, context, references) {
-            // not recursive
-            function clone /* <T> */(source, target) {
+            function clone(source, target) {
                 for (var prop in source) {
                     target[prop] = source[prop];
                 }
@@= skipped -19, +18 lines =@@
                 compileString(code, filename, callback, context, references);
             }
             finally {
-                // If settingsCallback exists, assume that it modified the global compiler instance's settings in some way.
-                // So that a test doesn't have side effects for tests run after it, restore the compiler settings to their previous state.
                 if (settingsCallback) {
                     compiler.settings = oldCompilerSettings;
                     compiler.emitSettings = oldEmitSettings;
@@= skipped -33, +31 lines =@@
                 context.preCompile();
             }
             var isDeclareFile = Harness.Compiler.isDeclareFile(unitName);
-            // for single file tests just add them as using the old '0.ts' naming scheme
             var uName = context ? unitName : ((isDeclareFile) ? '0.d.ts' : '0.ts');
             scripts.push(addUnit(code, uName, false, isDeclareFile, references));
             compile(code, uName);
             var errors;
             if (Harness.usePull) {
-                // TODO: no emit support with pull yet
                 errors = compiler.pullGetErrorsForFile(uName);
                 emit(stdout, true);
             }
             else {
                 errors = stderr.lines;
                 emit(stdout, false);
-                //output decl file
                 compiler.emitDeclarations();
             }
             if (context) {
@@= skipped -22, +19 lines =@@
             callback(new CompilerResult(stdout.toArray(), errors, scripts));
         }
         Compiler.compileString = compileString;
-        /** Returns a set of functions which can be later executed to add and remove given dependencies to the compiler so that
-         *  a file can be successfully compiled. These functions will add/remove named units and code to the compiler for each dependency.
-         */
         function defineCompilationContextForTest(filename, dependencies) {
-            // if the given file has no dependencies, there is no context to return, it can be compiled without additional work
             if (dependencies.length == 0) {
                 return null;
             }
             else {
                 var addedFiles = [];
-                var precompile = function () {
-                    // REVIEW: if any dependency has a triple slash reference then does postCompile potentially have to do a recreate since we can't update references with updateUnit?
-                    // easy enough to do if so, prefer to avoid the recreate cost until it proves to be an issue
-                    dependencies.forEach(function (dep) {
+                var precompile = () => {
+                    dependencies.forEach(dep => {
                         addUnit(dep.content, dep.name, false, Harness.Compiler.isDeclareFile(dep.name));
                         addedFiles.push(dep.name);
                     });
                 };
-                var postcompile = function () {
-                    addedFiles.forEach(function (file) {
+                var postcompile = () => {
+                    addedFiles.forEach(file => {
                         updateUnit('', file);
                     });
                 };
@@= skipped -33, +27 lines =@@
         }
         Compiler.defineCompilationContextForTest = defineCompilationContextForTest;
     })(Compiler = Harness.Compiler || (Harness.Compiler = {}));
-    /** Parses the test cases files
-     *  extracts options and individual files in a multifile test
-     */
-    var TestCaseParser;
+    let TestCaseParser;
     (function (TestCaseParser) {
-        optionRegex = /^[\/]{2}\s*@(\w+):\s*(\S*)/gm; // multiple matches on multiple lines
-        // List of allowed metadata names
+        optionRegex = /^[\/]{2}\s*@(\w+):\s*(\S*)/gm;
         var fileMetadataNames = ["filename", "comments", "declaration", "module", "nolib", "sourcemap", "target", "out"];
         function extractCompilerSettings(content) {
             var opts = [];
@@= skipped -16, +12 lines =@@
             }
             return opts;
         }
-        /** Given a test file containing // @Filename directives, return an array of named units of code to be added to an existing compiler instance */
         function makeUnitsFromTest(code, filename) {
             var settings = extractCompilerSettings(code);
-            // List of all the subfiles we've parsed out
             var files = [];
             var lines = splitContentByNewlines(code);
-            // Stuff related to the subfile we're parsing
             var currentFileContent = null;
             var currentFileOptions = {};
             var currentFileName = null;
@@= skipped -15, +12 lines =@@
                 var line = lines[i];
                 var isTripleSlashReference = /[\/]{3}\s*<reference path/.test(line);
                 var testMetaData = optionRegex.exec(line);
-                // Triple slash references need to be tracked as they are added to the compiler as an additional parameter to addUnit
                 if (isTripleSlashReference) {
                     var isRef = line.match(/reference\spath='(\w*_?\w*\.?d?\.ts)'/);
                     if (isRef) {
@@= skipped -16, +15 lines =@@
                     }
                 }
                 else if (testMetaData) {
-                    // Comment line, check for global/file @options and record them
                     optionRegex.lastIndex = 0;
                     var fileNameIndex = fileMetadataNames.indexOf(testMetaData[1].toLowerCase());
                     if (fileNameIndex == -1) {
@@= skipped -12, +11 lines =@@
                     else {
                         continue;
                     }
-                    // New metadata statement after having collected some code to go with the previous metadata
                     if (currentFileName) {
-                        // Store result file
                         var newTestFile = {
                             content: currentFileContent,
                             name: currentFileName,
@@= skipped -11, +9 lines =@@
                             references: refs
                         };
                         files.push(newTestFile);
-                        // Reset local data
                         currentFileContent = null;
                         currentFileOptions = {};
                         currentFileName = testMetaData[2];
                         refs = [];
                     }
                     else {
-                        // First metadata marker in the file
                         currentFileName = testMetaData[2];
                     }
                 }
                 else {
-                    // Subfile content line
-                    // Append to the current subfile content, inserting a newline needed
                     if (currentFileContent === null) {
                         currentFileContent = '';
                     }
                     else {
-                        // End-of-line
                         currentFileContent = currentFileContent + '\n';
                     }
                     currentFileContent = currentFileContent + line;
                 }
             }
-            // normalize the filename for the single file case
             currentFileName = files.length > 0 ? currentFileName : '0.ts';
-            // EOF, push whatever remains
             var newTestFile = {
                 content: currentFileContent || '',
                 name: currentFileName,
@@= skipped -39, +32 lines =@@
         }
         TestCaseParser.makeUnitsFromTest = makeUnitsFromTest;
     })(TestCaseParser = Harness.TestCaseParser || (Harness.TestCaseParser = {}));
-    var ScriptInfo = /** @class */ (function () {
-        function ScriptInfo(name, content, isResident, maxScriptVersions) {
+    class ScriptInfo {
+        name;
+        content;
+        isResident;
+        maxScriptVersions;
+        version;
+        editRanges = [];
+        constructor(name, content, isResident, maxScriptVersions) {
             this.name = name;
             this.content = content;
             this.isResident = isResident;
             this.maxScriptVersions = maxScriptVersions;
-            this.editRanges = [];
             this.version = 1;
         }
-        ScriptInfo.prototype.updateContent = function (content, isResident) {
+        updateContent(content, isResident) {
             this.editRanges = [];
             this.content = content;
             this.isResident = isResident;
             this.version++;
-        };
-        ScriptInfo.prototype.editContent = function (minChar, limChar, newText) {
-            // Apply edits
+        }
+        editContent(minChar, limChar, newText) {
             var prefix = this.content.substring(0, minChar);
             var middle = newText;
             var suffix = this.content.substring(limChar);
             this.content = prefix + middle + suffix;
-            // Store edit range + new length of script
             this.editRanges.push({
                 length: this.content.length,
                 editRange: new TypeScript.ScriptEditRange(minChar, limChar, (limChar - minChar) + newText.length)
@@= skipped -29, +32 lines =@@
             if (this.editRanges.length > this.maxScriptVersions) {
                 this.editRanges.splice(0, this.maxScriptVersions - this.editRanges.length);
             }
-            // Update version #
             this.version++;
-        };
-        ScriptInfo.prototype.getEditRangeSinceVersion = function (version) {
+        }
+        getEditRangeSinceVersion(version) {
             if (this.version == version) {
-                // No edits!
                 return null;
             }
             var initialEditRangeIndex = this.editRanges.length - (this.version - version);
             if (initialEditRangeIndex < 0 || initialEditRangeIndex >= this.editRanges.length) {
-                // Too far away from what we know
                 return TypeScript.ScriptEditRange.unknown();
             }
             var entries = this.editRanges.slice(initialEditRangeIndex);
-            var minDistFromStart = entries.map(function (x) { return x.editRange.minChar; }).reduce(function (prev, current) { return Math.min(prev, current); });
-            var minDistFromEnd = entries.map(function (x) { return x.length - x.editRange.limChar; }).reduce(function (prev, current) { return Math.min(prev, current); });
-            var aggDelta = entries.map(function (x) { return x.editRange.delta; }).reduce(function (prev, current) { return prev + current; });
+            var minDistFromStart = entries.map(x => x.editRange.minChar).reduce((prev, current) => Math.min(prev, current));
+            var minDistFromEnd = entries.map(x => x.length - x.editRange.limChar).reduce((prev, current) => Math.min(prev, current));
+            var aggDelta = entries.map(x => x.editRange.delta).reduce((prev, current) => prev + current);
             return new TypeScript.ScriptEditRange(minDistFromStart, entries[0].length - minDistFromEnd, aggDelta);
-        };
-        return ScriptInfo;
-    }());
-    Harness.ScriptInfo = ScriptInfo;
-    var TypeScriptLS = /** @class */ (function () {
-        function TypeScriptLS() {
-            this.ls = null;
-            this.scripts = [];
-            this.maxScriptVersions = 100;
         }
-        TypeScriptLS.prototype.addDefaultLibrary = function () {
+    }
+    Harness.ScriptInfo = ScriptInfo;
+    class TypeScriptLS {
+        ls = null;
+        scripts = [];
+        maxScriptVersions = 100;
+        addDefaultLibrary() {
             this.addScript("lib.d.ts", Harness.Compiler.libText, true);
-        };
-        TypeScriptLS.prototype.addFile = function (name, isResident) {
-            if (isResident === void 0) { isResident = false; }
+        }
+        addFile(name, isResident = false) {
             var code = readFile(name);
             this.addScript(name, code, isResident);
-        };
-        TypeScriptLS.prototype.addScript = function (name, content, isResident) {
-            if (isResident === void 0) { isResident = false; }
+        }
+        addScript(name, content, isResident = false) {
             var script = new ScriptInfo(name, content, isResident, this.maxScriptVersions);
             this.scripts.push(script);
-        };
-        TypeScriptLS.prototype.updateScript = function (name, content, isResident) {
-            if (isResident === void 0) { isResident = false; }
+        }
+        updateScript(name, content, isResident = false) {
             for (var i = 0; i < this.scripts.length; i++) {
                 if (this.scripts[i].name == name) {
                     this.scripts[i].updateContent(content, isResident);
@@= skipped -50, +41 lines =@@
                 }
             }
             this.addScript(name, content, isResident);
-        };
-        TypeScriptLS.prototype.editScript = function (name, minChar, limChar, newText) {
+        }
+        editScript(name, minChar, limChar, newText) {
             for (var i = 0; i < this.scripts.length; i++) {
                 if (this.scripts[i].name == name) {
                     this.scripts[i].editContent(minChar, limChar, newText);
@@= skipped -9, +9 lines =@@
                 }
             }
             throw new Error("No script with name '" + name + "'");
-        };
-        TypeScriptLS.prototype.getScriptContent = function (scriptIndex) {
+        }
+        getScriptContent(scriptIndex) {
             return this.scripts[scriptIndex].content;
-        };
-        //////////////////////////////////////////////////////////////////////
-        // ILogger implementation
-        //
-        TypeScriptLS.prototype.information = function () { return false; };
-        TypeScriptLS.prototype.debug = function () { return true; };
-        TypeScriptLS.prototype.warning = function () { return true; };
-        TypeScriptLS.prototype.error = function () { return true; };
-        TypeScriptLS.prototype.fatal = function () { return true; };
-        TypeScriptLS.prototype.log = function (s) {
-            // For debugging...
-            //IO.printLine("TypeScriptLS:" + s);
-        };
-        //////////////////////////////////////////////////////////////////////
-        // ILanguageServiceShimHost implementation
-        //
-        TypeScriptLS.prototype.getCompilationSettings = function () {
-            return ""; // i.e. default settings
-        };
-        TypeScriptLS.prototype.getScriptCount = function () {
+        }
+        information() { return false; }
+        debug() { return true; }
+        warning() { return true; }
+        error() { return true; }
+        fatal() { return true; }
+        log(s) {
+        }
+        getCompilationSettings() {
+            return "";
+        }
+        getScriptCount() {
             return this.scripts.length;
-        };
-        TypeScriptLS.prototype.getScriptSourceText = function (scriptIndex, start, end) {
+        }
+        getScriptSourceText(scriptIndex, start, end) {
             return this.scripts[scriptIndex].content.substring(start, end);
-        };
-        TypeScriptLS.prototype.getScriptSourceLength = function (scriptIndex) {
+        }
+        getScriptSourceLength(scriptIndex) {
             return this.scripts[scriptIndex].content.length;
-        };
-        TypeScriptLS.prototype.getScriptId = function (scriptIndex) {
+        }
+        getScriptId(scriptIndex) {
             return this.scripts[scriptIndex].name;
-        };
-        TypeScriptLS.prototype.getScriptIsResident = function (scriptIndex) {
+        }
+        getScriptIsResident(scriptIndex) {
             return this.scripts[scriptIndex].isResident;
-        };
-        TypeScriptLS.prototype.getScriptVersion = function (scriptIndex) {
+        }
+        getScriptVersion(scriptIndex) {
             return this.scripts[scriptIndex].version;
-        };
-        TypeScriptLS.prototype.getScriptEditRangeSinceVersion = function (scriptIndex, scriptVersion) {
+        }
+        getScriptEditRangeSinceVersion(scriptIndex, scriptVersion) {
             var range = this.scripts[scriptIndex].getEditRangeSinceVersion(scriptVersion);
             var result = (range.minChar + "," + range.limChar + "," + range.delta);
             return result;
-        };
-        /** Return a new instance of the language service shim, up-to-date wrt to typecheck.
-         *  To access the non-shim (i.e. actual) language service, use the "ls.languageService" property.
-         */
-        TypeScriptLS.prototype.getLanguageService = function () {
+        }
+        getLanguageService() {
             var ls = new Services.TypeScriptServicesFactory().createLanguageServiceShim(this);
             ls.refresh(true);
             this.ls = ls;
             return ls;
-        };
-        /** Parse file given its source text */
-        TypeScriptLS.prototype.parseSourceText = function (fileName, sourceText) {
+        }
+        parseSourceText(fileName, sourceText) {
             var parser = new TypeScript.Parser();
             parser.setErrorRecovery(null);
-            parser.errorCallback = function (a, b, c, d) { };
+            parser.errorCallback = (a, b, c, d) => { };
             var script = parser.parse(sourceText, fileName, 0);
             return script;
-        };
-        /** Parse a file on disk given its filename */
-        TypeScriptLS.prototype.parseFile = function (fileName) {
+        }
+        parseFile(fileName) {
             var sourceText = new TypeScript.StringSourceText(IO.readFile(fileName));
             return this.parseSourceText(fileName, sourceText);
-        };
-        /**
-         * @param line 1 based index
-         * @param col 1 based index
-        */
-        TypeScriptLS.prototype.lineColToPosition = function (fileName, line, col) {
+        }
+        lineColToPosition(fileName, line, col) {
             var script = this.ls.languageService.getScriptAST(fileName);
             assert.notNull(script);
             assert.is(line >= 1);
             assert.is(col >= 1);
             assert.is(line <= script.locationInfo.lineMap.length);
             return TypeScript.getPositionFromZeroBasedLineColumn(script, line - 1, col - 1);
-        };
-        /**
-         * @param line 0 based index
-         * @param col 0 based index
-        */
-        TypeScriptLS.prototype.positionToZeroBasedLineCol = function (fileName, position) {
+        }
+        positionToZeroBasedLineCol(fileName, position) {
             var script = this.ls.languageService.getScriptAST(fileName);
             assert.notNull(script);
             var result = TypeScript.getZeroBasedLineColumnFromPosition(script, position);
             assert.is(result.line >= 0);
             assert.is(result.col >= 0);
             return result;
-        };
-        /** Verify that applying edits to sourceFileName result in the content of the file baselineFileName */
-        TypeScriptLS.prototype.checkEdits = function (sourceFileName, baselineFileName, edits) {
+        }
+        checkEdits(sourceFileName, baselineFileName, edits) {
             var script = readFile(sourceFileName);
             var formattedScript = this.applyEdits(script, edits);
             var baseline = readFile(baselineFileName);
             assert.noDiff(formattedScript, baseline);
             assert.equal(formattedScript, baseline);
-        };
-        /** Apply an array of text edits to a string, and return the resulting string. */
-        TypeScriptLS.prototype.applyEdits = function (content, edits) {
+        }
+        applyEdits(content, edits) {
             var result = content;
             edits = this.normalizeEdits(edits);
             for (var i = edits.length - 1; i >= 0; i--) {
@@= skipped -111, +88 lines =@@
                 result = prefix + middle + suffix;
             }
             return result;
-        };
-        /** Normalize an array of edits by removing overlapping entries and sorting entries on the minChar position. */
-        TypeScriptLS.prototype.normalizeEdits = function (edits) {
+        }
+        normalizeEdits(edits) {
             var result = [];
             function mapEdits(edits) {
                 var result = [];
@@= skipped -21, +20 lines =@@
             var next = 1;
             while (current < temp.length) {
                 var currentEdit = temp[current].edit;
-                // Last edit
                 if (next >= temp.length) {
                     result.push(currentEdit);
                     current++;
@@= skipped -8, +7 lines =@@
                 }
                 var nextEdit = temp[next].edit;
                 var gap = nextEdit.minChar - currentEdit.limChar;
-                // non-overlapping edits
                 if (gap >= 0) {
                     result.push(currentEdit);
                     current = next;
                     next++;
                     continue;
                 }
-                // overlapping edits: for now, we only support ignoring an next edit 
-                // entirely contained in the current edit.
                 if (currentEdit.limChar >= nextEdit.limChar) {
                     next++;
                     continue;
@@= skipped -18, +15 lines =@@
                 }
             }
             return result;
-        };
-        TypeScriptLS.prototype.getHostSettings = function () {
+        }
+        getHostSettings() {
             return JSON.stringify({ usePullLanguageService: Harness.usePull });
-        };
-        return TypeScriptLS;
-    }());
+        }
+    }
     Harness.TypeScriptLS = TypeScriptLS;
-    // Describe/it definitions
     function describe(description, block) {
         var newScenario = new Scenario(description, block);
         if (Runnable.currentStack.length === 0) {
@@= skipped -29, +27 lines =@@
         currentRun.run();
     }
     Harness.run = run;
-    /** Runs TypeScript or Javascript code. */
-    var Runner;
+    let Runner;
     (function (Runner) {
         function runCollateral(path, callback) {
             path = switchToForwardSlashes(path);
@@= skipped -9, +8 lines =@@
         }
         Runner.runCollateral = runCollateral;
         function runJSString(code, callback) {
-            // List of names that get overriden by various test code we eval
             var dangerNames = ['Array'];
             var globalBackup = {};
             var n = null;
@@= skipped -29, +28 lines =@@
         }
         Runner.runString = runString;
     })(Runner = Harness.Runner || (Harness.Runner = {}));
-    /** Support class for baseline files */
-    var Baseline;
+    let Baseline;
     (function (Baseline) {
         var reportFilename = 'baseline-report.html';
         var firstRun = true;
@@= skipped -41, +40 lines =@@
         Baseline.reset = reset;
         function prepareBaselineReport() {
             var reportContent = htmlLeader;
-            // Delete the baseline-report.html file if needed
             if (IO.fileExists(reportFilename)) {
                 reportContent = IO.readFile(reportFilename);
                 reportContent = reportContent.replace(htmlTrailer, '');
@@= skipped -11, +10 lines =@@
             return reportContent;
         }
         function generateActual(actualFilename, generateContent) {
-            // Create folders if needed
             IO.createDirectory(IO.dirName(IO.dirName(actualFilename)));
             IO.createDirectory(IO.dirName(actualFilename));
-            // Delete the actual file in case it fails
             if (IO.fileExists(actualFilename)) {
                 IO.deleteFile(actualFilename);
             }
@@= skipped -11, +9 lines =@@
             if (actual === undefined) {
                 throw new Error('The generated content was "undefined". Return "null" if no baselining is required."');
             }
-            // Store the content in the 'local' folder so we
-            // can accept it later (manually)
             if (actual !== null) {
                 IO.writeFile(actualFilename, actual);
             }
             return actual;
         }
         function compareToBaseline(actual, relativeFilename, opts) {
-            // actual is now either undefined (the generator had an error), null (no file requested),
-            // or some real output of the function
             if (actual === undefined) {
-                // Nothing to do
                 return;
             }
             var refFilename = referencePath(relativeFilename);
@@= skipped -31, +26 lines =@@
         }
         function writeComparison(expected, actual, relativeFilename, actualFilename, descriptionForDescribe) {
             if (expected != actual) {
-                // Overwrite & issue error
                 var errMsg = 'The baseline file ' + relativeFilename + ' has changed. Please refer to baseline-report.html and ';
                 errMsg += 'either fix the regression (if unintended) or run nmake baseline-accept (if intended).';
                 var refFilename = referencePath(relativeFilename);
-                // Append diff to the report
                 var diff = new Diff.StringDiff(expected, actual);
                 var header = '<h2>' + descriptionForDescribe + '</h2>';
                 header += '<h4>Left file: ' + actualFilename + '; Right file: ' + refFilename + '</h4>';
@@= skipped -15, +13 lines =@@
                 throw new Error(errMsg);
             }
         }
-        function runBaseline(descriptionForDescribe, relativeFilename, generateContent, runImmediately, opts) {
-            if (runImmediately === void 0) { runImmediately = false; }
+        function runBaseline(descriptionForDescribe, relativeFilename, generateContent, runImmediately = false, opts) {
             var actual = undefined;
             var actualFilename = localPath(relativeFilename);
             if (runImmediately) {
@@= skipped -10, +9 lines =@@
                 writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);
             }
             else {
-                describe(descriptionForDescribe, function () {
+                describe(descriptionForDescribe, () => {
                     var actual;
-                    it('Can generate the content without error', function () {
+                    it('Can generate the content without error', () => {
                         actual = generateActual(actualFilename, generateContent);
                     });
-                    it('Matches the baseline file', function () {
+                    it('Matches the baseline file', () => {
                         var comparison = compareToBaseline(actual, relativeFilename, opts);
                         writeComparison(comparison.expected, comparison.actual, relativeFilename, actualFilename, descriptionForDescribe);
                     });
